
#Область ПРОГРАММНЫЙ_ИНТЕРФЕЙС

Процедура УстановитьСнятьПометкуУдаленияПриВыводеВводеДУ(Источник, Отказ) Экспорт
	
	Если Источник.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	ПометкаУдаления = Источник.ПометкаУдаления;
	Если Не ПометкаУдаления И Не Источник.ДополнительныеСвойства.Свойство("СнятаПометкаУдаления") Тогда
		Возврат;
	КонецЕсли;
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ВводВыводЦенныхБумагИзДУ.Ссылка
	|ИЗ
	|	Документ.ВводВыводЦенныхБумагИзДУ КАК ВводВыводЦенныхБумагИзДУ
	|ГДЕ
	|	ВводВыводЦенныхБумагИзДУ.ДокументОснование = &ДокументОснование
	|	И ВводВыводЦенныхБумагИзДУ.ПометкаУдаления = &ПометкаУдаления";
		
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("ДокументОснование", Источник.Ссылка);
	Запрос.УстановитьПараметр("ПометкаУдаления", Не ПометкаУдаления);
	
	УстановитьПривилегированныйРежим(Истина);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		СвязанныйДокументОбъект = Выборка.Ссылка.ПолучитьОбъект();
		СвязанныйДокументОбъект.УстановитьПометкуУдаления(ПометкаУдаления);
		СвязанныйДокументОбъект.ДополнительныеСвойства.Вставить("ПометкаУдаленияЗаметки", Истина);
		Попытка
			СвязанныйДокументОбъект.Записать();
		Исключение
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ЗаписьЖурналаРегистрации(НСтр("ru = 'ВводВыводИзДУ.Изменение пометки удаления'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка, СвязанныйДокументОбъект.Метаданные(), СвязанныйДокументОбъект.Ссылка, ТекстОшибки);
		КонецПопытки;
	КонецЦикла;
	
КонецПроцедуры

// Функция возвращает таблицу счетов. 
//
// Параметры:
//  СчетаБлокировки - Счет или Массив счетов, которые попадут в результирующую таблицу.
//
// Возвращаемое значение:
//	Возвращается значение - таблица значений с колонкой Счет.
//
Функция ПодготовитьТаблицуСчетовБлокировки(Знач СчетаБлокировки) Экспорт
	
	ТаблицаСчетаБлокировки = Новый ТаблицаЗначений;
	ТаблицаСчетаБлокировки.Колонки.Добавить("Счет");
	
	Если ТипЗнч(СчетаБлокировки) = Тип("Массив") Тогда 
		Для Каждого ТекСчет из СчетаБлокировки Цикл
			СтрокаТаблицыСчетаБлокировки = ТаблицаСчетаБлокировки.Добавить();
			СтрокаТаблицыСчетаБлокировки.Счет = ТекСчет;			
		КонецЦикла;
	ИначеЕсли ТипЗнч(СчетаБлокировки) = Тип("ПланСчетовСсылка.ЕПС") Тогда
		СтрокаТаблицыСчетаБлокировки = ТаблицаСчетаБлокировки.Добавить();
		СтрокаТаблицыСчетаБлокировки.Счет = СчетаБлокировки;
	КонецЕсли;
	Возврат ТаблицаСчетаБлокировки;
	
КонецФункции

// Функция возвращает таблицу только строк по облигациям. 
//
// Параметры:
//  ТаблицаАктивов - Таблица содержащая колонку ЭтоОблигация.
//
// Возвращаемое значение:
//	Возвращается значение - таблица .
//
Функция ОблигацииИз(ТаблицаАктивов) Экспорт 
	
	МассивВидовДолговыхЦБ = ПланыВидовХарактеристик.ВидыАктивов.ДолговыеЦБ();
	
	МассивАктивов = Новый Массив;
	
	Для Каждого СтрокаТЧ Из ТаблицаАктивов Цикл
		Если МассивВидовДолговыхЦБ.Найти(СтрокаТЧ.ВидАктива) <> Неопределено	Тогда 
			МассивАктивов.Добавить(СтрокаТЧ.Актив);
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивАктивов;
	
КонецФункции

// Функция возвращает таблицу только строк по Акциям. 
//
// Параметры:
//  ТаблицаАктивов - Таблица содержащая колонку ЭтоОблигация.
//
// Возвращаемое значение:
//	Возвращается значение - таблица.
//
Функция АкцииИз(ТаблицаАктивов) Экспорт 
	
	МассивВидовДолевыхЦБ = ПланыВидовХарактеристик.ВидыАктивов.ДолевыеЦБ();
	
	МассивАктивов = Новый Массив;
	
	Для Каждого СтрокаТЧ Из ТаблицаАктивов Цикл
		Если МассивВидовДолевыхЦБ.Найти(СтрокаТЧ.ВидАктива) <> Неопределено	Тогда 
			МассивАктивов.Добавить(СтрокаТЧ.Актив);
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивАктивов;	
	
КонецФункции

// Функция возвращает таблицу только строк по Производным ФИ. 
//
// Параметры:
//  ТаблицаАктивов - Таблица содержащая колонку ТипАктиваЦБРФ.
//
// Возвращаемое значение:
//	Возвращается значение - таблица.
//
Функция ПроизводныеФИИз(ТаблицаАктивов) Экспорт 
	
	МассивПроизводныеЦБ = ПланыВидовХарактеристик.ВидыАктивов.ПроизводныеЦБ();
	
	МассивАктивов = Новый Массив;
	
	Для Каждого СтрокаТЧ Из ТаблицаАктивов Цикл
		Если МассивПроизводныеЦБ.Найти(СтрокаТЧ.ВидАктива) <> Неопределено	Тогда 
			МассивАктивов.Добавить(СтрокаТЧ.Актив);
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивАктивов;
	
КонецФункции

// Функция возвращает Договор контрагента из Партии. 
//
// Параметры:
//  Партия - СправочникСсылка\ БизнесПроцессСсылка.
//
// Возвращаемое значение:
//	Возвращается значение - СправочникСсылка.ДоговорыКонтрагентов.
//
Функция ДоговорПартии(Партия) Экспорт 
	
	Договор = Справочники.ДоговорыКонтрагентов.ПустаяСсылка();
	
	Если ТипЗнч(Партия) = Тип("ДокументСсылка.Сделка") 
		Или ТипЗнч(Партия) = Тип("ДокументСсылка.ОткрытиеПлановойПозиции") 
		Или ТипЗнч(Партия) = Тип("ДокументСсылка.ДокументРасчетовСКонтрагентом") 
		Или ТипЗнч(Партия) = Тип("ДокументСсылка.КлирингОткрытыхПозиций") 
		Или ТипЗнч(Партия) = Тип("БизнесПроцессСсылка.ВнебиржеваяСделка") 
		Или ТипЗнч(Партия) = Тип("БизнесПроцессСсылка.СделкиTn") 
		Или ТипЗнч(Партия) = Тип("БизнесПроцессСсылка.СделкиРЕПО") 
		Тогда
		
		Договор = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Партия, "ДоговорКонтрагента");
		
	КонецЕсли;
	
	Возврат Договор;
	
КонецФункции

// Процедура устанавливает счет в проводке
//
// Параметры:
//  Проводка		 - РегистрБухгалтерииЗапись	 - Проводка
//  ЧастьПроводки	 - Строка	 - "Дт" или "Кт"
//  Счет		 - ПланСчетовСсылка - Счет
//
Процедура УстановитьСчет(Проводка, ЧастьПроводки, Счет) Экспорт
	
	Проводка["Счет" + ЧастьПроводки] = Счет;
	
КонецПроцедуры

// Процедура устанавливает субконто в проводке
//
// Параметры:
//  Проводка		 - РегистрБухгалтерииЗапись	 - Проводка
//  ЧастьПроводки	 - Строка	 - "Дт" или "Кт"
//  ИмяСубконто		 - ПланВидовХарактеристикСсылка,Число,Строка	 - Субконто
//  ЗначениеСубконто - Произвольный	 - Значение субконто
//
Процедура УстановитьСубконто(Проводка, ЧастьПроводки, ИмяСубконто, ЗначениеСубконто) Экспорт
	
	Перем ТипСубконто;
	
	Если НЕ ЗначениеЗаполнено(ИмяСубконто) Тогда
		Возврат;
	КонецЕсли;                                     
	
	СвойстваСчета = УчетЕПСПовтИсп.СвойстваСчета(Проводка["Счет" + ЧастьПроводки]);
	
	Если ТипЗнч(ИмяСубконто) = Тип("ПланВидовХарактеристикСсылка.ВидыСубконтоЕПС") Тогда
		ВидСубконто = ИмяСубконто;
		Если СвойстваСчета.ВидСубконто1 <> ВидСубконто
			И СвойстваСчета.ВидСубконто2 <> ВидСубконто
			И СвойстваСчета.ВидСубконто3 <> ВидСубконто Тогда			
			Возврат;			
		КонецЕсли;		
		
	ИначеЕсли ТипЗнч(ИмяСубконто) = Тип("Число") Тогда
		Если ИмяСубконто > СвойстваСчета.КоличествоСубконто Тогда
			Возврат;
		КонецЕсли;		
		ВидСубконто = СвойстваСчета["ВидСубконто" + ИмяСубконто];
		ТипСубконто = СвойстваСчета["ВидСубконто" + ИмяСубконто + "ТипЗначения"];
		
	Иначе		
		ВидСубконто = ПланыВидовХарактеристик.ВидыСубконтоЕПС[ИмяСубконто];
		Если СвойстваСчета.ВидСубконто1 <> ВидСубконто
			И СвойстваСчета.ВидСубконто2 <> ВидСубконто
			И СвойстваСчета.ВидСубконто3 <> ВидСубконто Тогда			
			Возврат;			
		КонецЕсли;
		
	КонецЕсли;
	
	Если ТипСубконто = Неопределено Тогда
		Если СвойстваСчета.ВидСубконто1 = ВидСубконто Тогда
			ТипСубконто = СвойстваСчета.ВидСубконто1ТипЗначения;
			
		ИначеЕсли СвойстваСчета.ВидСубконто2 = ВидСубконто Тогда 
			ТипСубконто = СвойстваСчета.ВидСубконто2ТипЗначения;
			
		ИначеЕсли СвойстваСчета.ВидСубконто3 = ВидСубконто Тогда 
			ТипСубконто = СвойстваСчета.ВидСубконто3ТипЗначения;
			
		КонецЕсли;		
	КонецЕсли; 
	
	Если ТипСубконто.СодержитТип(ТипЗнч(ЗначениеСубконто)) Тогда		
		Проводка["Субконто" + ЧастьПроводки].Вставить(ВидСубконто, ЗначениеСубконто);
		
	КонецЕсли;
	
КонецПроцедуры // УстановитьСубконто()
	
// Процедура устанавливает сумму НУ в проводку
//
// Параметры:
//  Проводка		 - РегистрБухгалтерииЗапись	 - Проводка
//  ЧастьПроводки	 - Строка	 - "Дт" или "Кт"
//  Сумма			 - Число	 - Сумма НУ
//
Процедура УстановитьСуммуНУ(Проводка, ЧастьПроводки, Сумма, ФлагНУ = Истина) Экспорт
	
	Если ФлагНУ Тогда
		
		СвойстваСчета = БухгалтерскийУчетПовтИсп.ПолучитьСвойстваСчетаЕПС(Проводка["Счет" + ЧастьПроводки]);
		
		Если СвойстваСчета.НалоговыйУчет Тогда
			Проводка["СуммаНУ" + ЧастьПроводки] = Сумма;
		КонецЕсли; 
		
	КонецЕсли; 
	
КонецПроцедуры

// Процедура устанавливает валюту и валютную сумму в проводку
//
// Параметры:
//  Проводка		 - РегистрБухгалтерииЗапись	 - Проводка
//  ЧастьПроводки	 - Строка	 - "Дт" или "Кт"
//  Валюта			 - СправочникСсылка	 - Валюта
//  Сумма			 - Число	 - Валютная сумма
//
Процедура УстановитьВалютнуюСумму(Проводка, ЧастьПроводки, Валюта, Сумма) Экспорт
	
	СвойстваСчета = БухгалтерскийУчетПовтИсп.ПолучитьСвойстваСчетаЕПС(Проводка["Счет" + ЧастьПроводки]);
	
	Если СвойстваСчета.Валютный Тогда
		Проводка["Валюта" + ЧастьПроводки] = Валюта;
		Проводка["ВалютнаяСумма" + ЧастьПроводки] = Сумма;
	КонецЕсли; 
	
КонецПроцедуры

// Процедура устанавливает количество в проводку
//
// Параметры:
//  Проводка		 - РегистрБухгалтерииЗапись	 - Проводка
//  ЧастьПроводки	 - Строка	 - "Дт" или "Кт"
//  Количество		 - Число	 - Количество
//
Процедура УстановитьКоличество(Проводка, ЧастьПроводки, Количество) Экспорт
	
	СвойстваСчета = БухгалтерскийУчетПовтИсп.ПолучитьСвойстваСчетаЕПС(Проводка["Счет" + ЧастьПроводки]);
	
	Если СвойстваСчета.Количественный Тогда
		Проводка["Количество" + ЧастьПроводки] = Количество;
	КонецЕсли; 
	
КонецПроцедуры

// Процедура сворачивает проводки
// Вызывается из модуля документа при проведении.
//
// Параметры:
//   Движения - коллекция движений документа
Процедура СвернутьПроводкиЕПС(Движения) Экспорт
	
	Если Движения.Найти("ЕПС") = Неопределено Тогда 
		Возврат;
	КонецЕсли;
	
	Таблица = Движения.ЕПС.Выгрузить();
	
	Колонки = Новый Массив;
	Для Каждого Колонка Из Таблица.Колонки Цикл
		Колонки.Добавить(Колонка.Имя);
	КонецЦикла;
	
	СуммируемыеКолонки = Новый Массив;
	СуммируемыеКолонки.Добавить("КоличествоДт");
	СуммируемыеКолонки.Добавить("ВалютнаяСуммаДт");
	СуммируемыеКолонки.Добавить("КоличествоКт");
	СуммируемыеКолонки.Добавить("ВалютнаяСуммаКт");
	СуммируемыеКолонки.Добавить("Сумма");
	СуммируемыеКолонки.Добавить("СуммаНУДт");
	СуммируемыеКолонки.Добавить("СуммаНУКт");
	
	Колонки = ОбщегоНазначенияКлиентСервер.СократитьМассив(Колонки, СуммируемыеКолонки);
	Колонки.Удалить(Колонки.Найти("Регистратор"));
	Колонки.Удалить(Колонки.Найти("НомерСтроки"));
	                                       
	Таблица.Свернуть(СтрСоединить(Колонки,","),
					 СтрСоединить(СуммируемыеКолонки,","));					 					 	 
					 
	Движения.ЕПС.Загрузить(Таблица);				 
		
КонецПроцедуры

#КонецОбласти

#Область РАБОТА_С_АНАЛИТИКОЙ

//	Функция возвращает пустое значение Коллекции аналитики
//
// Результат <Структура>
//
Функция ПустаяКоллекцияАналитики() Экспорт
	
	КоллекцияАналитики = Новый Структура;
	КоллекцияАналитики.Вставить("Аналитика1", Неопределено);
	КоллекцияАналитики.Вставить("Аналитика2", Неопределено);
	КоллекцияАналитики.Вставить("Аналитика3", Неопределено);
	КоллекцияАналитики.Вставить("Аналитика4", Неопределено);
	КоллекцияАналитики.Вставить("Аналитика5", Неопределено);
	
	Возврат КоллекцияАналитики;
	
КонецФункции

//	Функция возвращает пустое значение структуры значений аналитики
//
// Результат <Структура>
//
Функция ПустаяСтруктураЗначенийАналитики() Экспорт
	
	ЗначенияАналитики = Новый Структура;
	ЗначенияАналитики.Вставить("ЗначениеАналитики1", Неопределено);
	ЗначенияАналитики.Вставить("ЗначениеАналитики2", Неопределено);
	ЗначенияАналитики.Вставить("ЗначениеАналитики3", Неопределено);
	ЗначенияАналитики.Вставить("ЗначениеАналитики4", Неопределено);
	ЗначенияАналитики.Вставить("ЗначениеАналитики5", Неопределено);
	
	Возврат ЗначенияАналитики;
	
КонецФункции

// Процедура заполняет коллекцию аналитики по переданному значению аналитики, с учетом настроек конвертации значений аналитики. 
//
// Параметры:
//  Контекст - <Структура>. Структура, содержащая в себе данные из шапки документа откуда производится создание\поиск лицевого счета.
//  НастройкиАналитики - <Массив> - Настройки аналитики, пременяемые для данного счета.
//  КоллекцияАналитики - Структура со значениями аналитики, которая будет заполняться данной процедурой,
//			в случае если по переданному значению можно заполнить поле, которое есть в настройках.
//  Аналитика - ПланВидовХарактеристик.ВидыСубконтоЕПС - вид аналитики, для которой будет происходить заполнение.
//  ЗначениеАналитики - Характеристика.ПланВидовХарактеристик.ВидыСубконтоЕПС - значение аналитики для заполнения.
//
// Возвращаемое значение:
//	<Структура> - Возвращается структура значеий аналитики.
//- Если записи по переданной структуре отбора не найдено, то возвращается структура нужного вида со значениями неопределено.
//
Процедура УстановитьЗначениеАналитики(Контекст, НастройкиАналитики, КоллекцияАналитики, Аналитика, ЗначениеАналитики) Экспорт 
		
	НомерНастройкиАналитики = НастройкиАналитики.Найти(Аналитика); 
	Если НомерНастройкиАналитики <> Неопределено Тогда
		НомерАналитики = НомерНастройкиАналитики + 1;
		КоллекцияАналитики.Вставить("Аналитика" + НомерАналитики, ?(ЗначениеЗаполнено(ЗначениеАналитики), ЗначениеАналитики, Неопределено));
	КонецЕсли;
	
	Справочники.ПравилаКонвертацииАналитики.КонвертироватьЗначенияАналитики(Контекст, НастройкиАналитики, КоллекцияАналитики, Аналитика, ЗначениеАналитики);
	
КонецПроцедуры

// Функция ищет в переданной структуре значения опрделенного типа. 
//
// Параметры:
//  ОбрабатываемаяСтруктура - Структура в которой будет осуществлен поиск.
//  НужныйТип - Тип, значение которого будет искаться в структуре.
//
// Возвращаемое значение:
//	Возвращается значение из структуры, если нашлось значение нужного типа, или неопределено.
//
Функция ЗначениеОпределенногоТипаИзСтруктуры(ОбрабатываемаяСтруктура, НужныйТип) Экспорт 
	
	ВозвращаемоеЗначение = Неопределено;
	
	Для Каждого ЭлементСтруктуры из ОбрабатываемаяСтруктура Цикл
		Значение = ЭлементСтруктуры.Значение;
		Если ТипЗнч(Значение) = НужныйТип Тогда 
			ВозвращаемоеЗначение = Значение;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ВозвращаемоеЗначение;
	
КонецФункции

Функция КонтекстЛицевогоСчетаПоЧастиПроводки(Проводка, Регистратор, ЧастьПроводки) Экспорт
	
	Контекст = Новый Структура;
	Контекст.Вставить("Дата", Проводка.Период);
	Контекст.Вставить("Документ", Регистратор);
	Контекст.Вставить("Портфель", Проводка.Портфель);
	Контекст.Вставить("СчетЕПС", Проводка["Счет" + ЧастьПроводки]);
	СвойстваСчета = УчетЕПСПовтИсп.СвойстваСчета(Контекст.СчетЕПС);
	Если Не СвойстваСчета.Валютный Тогда
		Контекст.Вставить("Валюта", УА_ПривилегированныйСервер.ВалютаРеглУчета());
	Иначе
		Контекст.Вставить("Валюта", Проводка["Валюта" + ЧастьПроводки]);
	КонецЕсли;
	Возврат Контекст;
	
КонецФункции

Функция АналитикаЛицевогоСчетаПоЧастиПроводки(Проводка, ЧастьПроводки) Экспорт
	
	НеОборотныеСубконто = УчетЕПСПовтИсп.НеОборотныеСубконто(Проводка["Счет" + ЧастьПроводки]);

	АналитикаЛС = Новый Соответствие;
	Для Каждого Субконто Из НеОборотныеСубконто Цикл
		АналитикаЛС.Вставить(Субконто, Проводка["Субконто" + ЧастьПроводки][Субконто]);
	КонецЦикла; 
	
	Возврат АналитикаЛС;
	
КонецФункции

Процедура УстановитьЛицевойСчетВПроводку(Проводка, Регистратор, ЧастьПроводки, КэшПоискаЛицевыхСчетов) Экспорт
	
	Если Не ЗначениеЗаполнено(Проводка["Счет" + ЧастьПроводки]) Тогда 
		ОбратнаяЧастьПроводки = ?(ЧастьПроводки = "Дт", "Кт", "Дт");
		СтрокаСубконто = Новый Массив;
		Для Каждого Субконто Из Проводка["Субконто" + ОбратнаяЧастьПроводки] Цикл
			СтрокаСубконто.Добавить(СтрШаблон("%1: %2", Субконто.Ключ, Субконто.Значение));
		КонецЦикла;
		ТекстИсключения = СтрШаблон(
			"В одной из проводок не заполнен счет %2
			|Содержание: %3
			|Счет %4 <%5>, %6", 
				Проводка.НомерСтроки, ЧастьПроводки, Проводка.Содержание, 
				ОбратнаяЧастьПроводки, Проводка["Счет" + ОбратнаяЧастьПроводки],
				СтроковыеФункцииКлиентСервер.СтрокаИзМассиваПодстрок(СтрокаСубконто, ", ", Истина));
		ВызватьИсключение(ТекстИсключения);	
	КонецЕсли;
	
	Контекст = КонтекстЛицевогоСчетаПоЧастиПроводки(Проводка, Регистратор, ЧастьПроводки);
	АналитикаЛС = УчетЕПС.АналитикаЛицевогоСчетаПоЧастиПроводки(Проводка, ЧастьПроводки);
	
	ПроверитьКорректностьСозданияЛицевогоСчета(Проводка, ЧастьПроводки, Контекст, АналитикаЛС, КэшПоискаЛицевыхСчетов);
	
	ЛицевойСчет = Справочники.уа_ЛицевыеСчетаЕПС.СчетПоАналитике(Контекст, АналитикаЛС, Истина, Истина, КэшПоискаЛицевыхСчетов);
	Проводка["ЛицевойСчет" + ЧастьПроводки] = ЛицевойСчет;
	
КонецПроцедуры

// Процедура обеспечивает уникальность и последовательность записи
// реквизита КодДляЛицевогоСчета
//
// Параметры:
//  Источник - источник
//  Отказ - признак отказа, в случае ошибок
//
Процедура ЗаполнитьРеквизитКодДляЛицевогоСчета(Источник, Отказ) Экспорт
	
	Если Источник.ОбменДанными.Загрузка = Истина ИЛИ Источник.ПометкаУдаления = Истина ИЛИ Источник.ЭтоГруппа = Истина Тогда
		Возврат;
	КонецЕсли;
	
	МетаданныеСправочника = Источник.Метаданные();
	ИмяСправочника = МетаданныеСправочника.Имя;
	Если МетаданныеСправочника.Реквизиты.Найти("КодДляЛицевогоСчета") = Неопределено Тогда
		Возврат;
	КонецЕсли;
		
	Если ЗначениеЗаполнено(Источник.КодДляЛицевогоСчета) Тогда
		
		// Проверка на дубли
		
		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ
		|	СправочникДляОбработки.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.ИмяСправочника КАК СправочникДляОбработки
		|ГДЕ
		|	СправочникДляОбработки.КодДляЛицевогоСчета = &КодДляЛицевогоСчета
		|	И СправочникДляОбработки.Ссылка <> &Ссылка
		|
		|УПОРЯДОЧИТЬ ПО
		|	КодДляЛицевогоСчета УБЫВ";
		
		
		Если НЕ ПустаяСтрока(ИмяСправочника) Тогда
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИмяСправочника", ИмяСправочника); 
		КонецЕсли;
		
		Запрос.УстановитьПараметр("КодДляЛицевогоСчета",Источник.КодДляЛицевогоСчета);
		Запрос.УстановитьПараметр("Ссылка",Источник.Ссылка);
		
		Результат = Запрос.Выполнить();
		
		Выборка = Результат.Выбрать();
		Если Выборка.Следующий() Тогда
			
			ТекстСообщения = СтрШаблон(НСтр("ru = 'Значение реквизита ""Код для лицевого счета"": %1 не уникально. Такой же код установлен у ""%2""'"), Источник.КодДляЛицевогоСчета, Выборка.Ссылка);
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,Источник.Ссылка,"Объект.КодДляЛицевогоСчета",,Отказ);

		КонецЕсли;

	Иначе	
		
		// Установка кода для лицевого счета
		
		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникДляОбработки.КодДляЛицевогоСчета КАК КодДляЛицевогоСчета
		|ИЗ
		|	Справочник.ИмяСправочника КАК СправочникДляОбработки
		|
		|УПОРЯДОЧИТЬ ПО
		|	КодДляЛицевогоСчета УБЫВ";
		
		
		Если НЕ ПустаяСтрока(ИмяСправочника) Тогда
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИмяСправочника", ИмяСправочника); 
		КонецЕсли;
		
		Результат = Запрос.Выполнить();
		
		Выборка = Результат.Выбрать();
		Если Выборка.Следующий() И ЗначениеЗаполнено(Выборка.КодДляЛицевогоСчета) Тогда
			Источник.КодДляЛицевогоСчета = Выборка.КодДляЛицевогоСчета + 1;
		Иначе
			Источник.КодДляЛицевогоСчета = 1;
		КонецЕсли;
	
	КонецЕсли;	
	
	
КонецПроцедуры

// Процедура заполняет в проводке валюту валютой регламентированного учета
// в случае, если счет валютный и валюта не заполнена.
// Если валютная сумма не заполнена или валюта равна валюте регламентированного учета,
// валютная сумма устанавливается равной сумме проводки
Процедура ЗаполнитьВалютыВПроводке(Проводка) Экспорт
	
	ВалютаРегл = УА_ПривилегированныйСервер.ВалютаРеглУчета();
	
	МассивДтКт = Новый Массив;
	МассивДтКт.Добавить("Дт");
	МассивДтКт.Добавить("Кт");
	
	Для Каждого ДтКт из МассивДтКт Цикл
		
		Если ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Проводка["Счет" + ДтКт], "Валютный") = Истина Тогда
			
			Если Не ЗначениеЗаполнено(Проводка["Валюта" + ДтКт]) Тогда
				Проводка["Валюта" + ДтКт] = ВалютаРегл;
				Если Не ЗначениеЗаполнено(Проводка["ВалютнаяСумма" + ДтКт]) Тогда
					Проводка["ВалютнаяСумма" + ДтКт] = Проводка.Сумма;
				КонецЕсли; 
			ИначеЕсли Проводка["Валюта" + ДтКт] = ВалютаРегл Тогда   
				Проводка["ВалютнаяСумма" + ДтКт] = Проводка.Сумма;
			КонецЕсли;
			
			Если Проводка["Валюта" + ДтКт] = ВалютаРегл Тогда
				Проводка["ВалютнаяСумма" + ДтКт] = Проводка.Сумма;
			КонецЕсли;
			
		КонецЕсли;	
			
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область СЛУЖЕБНЫЕ_ПРОЦЕДУРЫ_ФУНКЦИИ

Процедура ПроверитьКорректностьСозданияЛицевогоСчета(Проводка, ЧастьПроводки, Контекст, АналитикаЛС, КэшПоискаЛицевыхСчетов)
	
	//Если ОбщегоНазначенияДУПовтИсп.ПолучитьЗначениеКонстанты("ЗапретитьОткрыватьЛицевыеСчетаСНеподходящимиСимволамиОФР") = Ложь Тогда
	//	Возврат;	
	//КонецЕсли;
	
	//АналитикаСимволыОФР = АналитикаЛС.Получить(ПланыВидовХарактеристик.ВидыСубконтоЕПС.СимволыОФР);
	//Если АналитикаСимволыОФР = Неопределено Тогда
	//	Возврат;
	//КонецЕсли;
	
	ЛицевойСчет = Справочники.уа_ЛицевыеСчетаЕПС.СчетПоАналитике(Контекст, АналитикаЛС, Ложь, Истина, КэшПоискаЛицевыхСчетов);
	Если ЗначениеЗаполнено(ЛицевойСчет) Тогда
		Возврат;
	КонецЕсли;
	
	СчетВторогоПорядкаЛицевогоСчета = ПланыСчетов.ЕПС.СчетВторогоПорядка(Контекст.СчетЕПС);
	ТекстОшибкиСимволаОФР = "";
	
	//Если ЗначениеЗаполнено(АналитикаСимволыОФР) Тогда
	//	
	//	СчетВторогоПорядкаСчетаДохода = ПланыСчетов.ЕПС.СчетВторогоПорядка(АналитикаСимволыОФР.СчетДохода);
	//	СчетВторогоПорядкаСчетаРасхода = ПланыСчетов.ЕПС.СчетВторогоПорядка(АналитикаСимволыОФР.СчетРасхода);
	//	
	//	Если СчетВторогоПорядкаЛицевогоСчета.Вид = ВидСчета.Пассивный Тогда 
	//		Если  Не (СчетВторогоПорядкаЛицевогоСчета = СчетВторогоПорядкаСчетаДохода Или СчетВторогоПорядкаЛицевогоСчета = УчетЕПСПовтИсп.СчетPnL_ДругогоГода(СчетВторогоПорядкаСчетаДохода)) Тогда
	//			ТекстОшибкиСимволаОФР = СтрШаблон("задан неверно - счет дохода %1 в символе ОФР %2 не равен %3", 
	//				СчетВторогоПорядкаСчетаДохода, АналитикаСимволыОФР, СчетВторогоПорядкаЛицевогоСчета);
	//		КонецЕсли;
	//	КонецЕсли;
	//	
	//	Если СчетВторогоПорядкаЛицевогоСчета.Вид = ВидСчета.Активный Тогда 
	//		Если Не (СчетВторогоПорядкаЛицевогоСчета = СчетВторогоПорядкаСчетаРасхода Или СчетВторогоПорядкаЛицевогоСчета = УчетЕПСПовтИсп.СчетPnL_ДругогоГода(СчетВторогоПорядкаСчетаРасхода)) Тогда
	//			ТекстОшибкиСимволаОФР = СтрШаблон("задан неверно - счет расхода %1 в символе ОФР %2 не равен %3",
	//				СчетВторогоПорядкаСчетаРасхода, АналитикаСимволыОФР, СчетВторогоПорядкаЛицевогоСчета);
	//		КонецЕсли;
	//	КонецЕсли;
	//	
	//Иначе	
	//	ТекстОшибкиСимволаОФР = "не заполнен";	
	//КонецЕсли;
	//
	//Если Не ПустаяСтрока(ТекстОшибкиСимволаОФР) Тогда
	//	
	//	СтрокаСубконто = Новый Массив;
	//	Для Каждого Субконто Из Проводка["Субконто" + ЧастьПроводки] Цикл
	//		СтрокаСубконто.Добавить(СтрШаблон("%1: %2", Субконто.Ключ, Субконто.Значение));
	//	КонецЦикла;
	//	
	//	СтрокаСубконтоКоррСчета = Новый Массив;
	//	ОбратнаяЧастьПроводки = ?(ЧастьПроводки = "Дт", "Кт", "Дт");
	//	Для Каждого Субконто Из Проводка["Субконто" + ОбратнаяЧастьПроводки] Цикл
	//		СтрокаСубконтоКоррСчета.Добавить(СтрШаблон("%1: %2", Субконто.Ключ, Субконто.Значение));
	//	КонецЦикла;
	//	
	//	ТекстИсключения = СтрШаблон("Ошибка проведения документа %1 при создании лицевого счета:
	//		|Символ ОФР по счету %2 %3.
	//		|Содержание: %4
	//		|Счет %9 %5 <%6>
	//		|Счет %10 %7 <%8>", 
	//			Контекст.Документ, СчетВторогоПорядкаЛицевогоСчета, ТекстОшибкиСимволаОФР, 
	//			Проводка.Содержание, Проводка["Счет" + ЧастьПроводки],
	//			СтрСоединить(СтрокаСубконто, ", "), Проводка["Счет" + ОбратнаяЧастьПроводки],
	//			СтрСоединить(СтрокаСубконтоКоррСчета, ", "), ЧастьПроводки, ОбратнаяЧастьПроводки);
	//	ВызватьИсключение(ТекстИсключения);
	//	
	//КонецЕсли;
	
КонецПроцедуры

Функция СтандартУчета(Объект) Экспорт

	Портфели = Новый Массив;  		
	Если ТипЗнч(Объект.КлиентДУ) <> Тип("СправочникСсылка.Портфели") Тогда      	
		Портфели = ОбщегоНазначенияДУПовтИсп.ПортфелиКлиентаДУ(Объект.КлиентДУ);	
	Иначе            	
		Портфели.Добавить(Объект.КлиентДУ);	
	КонецЕсли;
	
	СтандартУчетаПВХ = ПланыВидовХарактеристик.ПараметрыПортфеля.СтандартУчета; 
	СтандартУчетаЗначение = Неопределено;
	
	Если Портфели.Количество() <> 0 Тогда
		Для Индекс = 0 По Портфели.Количество() - 1 Цикл
			Если Индекс <> 0 Тогда
				СтандартУчетаОдинаковыйДляВсехПортфелей = СтандартУчетаЗначение = РегистрыСведений.ЗначенияПараметровПортфеля.ЗначенияПараметровПортфеля(Портфели[Индекс], СтандартУчетаПВХ).Получить(СтандартУчетаПВХ);
				Если НЕ СтандартУчетаОдинаковыйДляВсехПортфелей Тогда
					ТекстСообщения = СтрШаблон(НСтр("ru = 'Стандарт учета не во всех портфелях клиента одинаков. Проверьте настройки Учетной политики.'"),,);
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,,,,);
					Прервать;
				КонецЕсли;
			КонецЕсли;
			СтандартУчетаЗначение = РегистрыСведений.ЗначенияПараметровПортфеля.ЗначенияПараметровПортфеля(Портфели[Индекс], СтандартУчетаПВХ).Получить(СтандартУчетаПВХ);
		КонецЦикла;  			
	КонецЕсли;	
		
	Возврат СтандартУчетаЗначение;

КонецФункции 

#КонецОбласти