//////////////////////////////////////////////////////////////////////////////////
// ОБЩИЕ ПРОЦЕДУРЫ И ФУНКЦИИ

// Значение константы по имени
//
//Параметры:
// ИмяКонстанты - Строка
// ПолучатьДанныеХранилища - Булево
//
//Возвращаемое значение: 
// Произвольный - значение самой константы
//
Функция ЗначениеКонстанты(ИмяКонстанты, ПолучатьДанныеХранилища = Ложь) Экспорт		
	ЗначениеКонстанты = Константы[ИмяКонстанты].Получить();	
	Если ПолучатьДанныеХранилища И ТипЗнч(ЗначениеКонстанты) = Тип("ХранилищеЗначения") Тогда
		ЗначениеКонстанты  = ЗначениеКонстанты.Получить();		
	КонецЕсли; 
	
	Возврат ЗначениеКонстанты;
	
КонецФункции

//Процедура используется для отладки сложных запросов с временными таблицами  
//
// Параметры:
//    ОбъектОтладки - объект отладки
//    ИмяСекции - имя секции в логе отладки
//
// лог отладки выводится в табличный документ
//
Процедура ДобавитьВЛогОтладки(ОбъектОтладки, ИмяСекции = "") Экспорт
	//Не используем
	Возврат;
	
	//Если Не ПолныеПрава.ФормироватьЛогОтладки() Тогда 
	//	Возврат; 
	//КонецЕсли;
	
	ТекущийЛог = Новый ТабличныйДокумент;
	
	Если ТипЗнч(ОбъектОтладки) = Тип("Запрос") Тогда 
		ТекущийЛог = ЗначениеЗапроса(ОбъектОтладки, ИмяСекции); 
	ИначеЕсли ТипЗнч(ОбъектОтладки) = Тип("Строка") Тогда
		ТекущийЛог = ЗначениеТекстовогоПоля(ОбъектОтладки, ИмяСекции);; 	
	ИначеЕсли ТипЗнч(ОбъектОтладки) = Тип("ТаблицаЗначений")
			Или ТипЗнч(ОбъектОтладки) = Тип("ДеревоЗначений") Тогда
		ТекущийЛог = ЗначениеТаблицыЗначенийДереваЗначений(ОбъектОтладки, ИмяСекции);
	ИначеЕсли ТипЗнч(ОбъектОтладки) = Тип("РезультатЗапроса") Тогда
		ТаблицаЗначений = ОбъектОтладки.Выгрузить();
		ТекущийЛог = ЗначениеТаблицыЗначенийДереваЗначений(ТаблицаЗначений, ИмяСекции);
	ИначеЕсли ТипЗнч(ОбъектОтладки) = Тип("ТабличныйДокумент") Тогда
		ТекущийЛог = ЗначениеТабличногоДокуммента(ОбъектОтладки, ИмяСекции);
	Иначе
		Возврат;
	КонецЕсли;
	
	
	АдресРезультата = ПараметрыСеанса.РезультатОтладки;
	
	ТекущийЛог.Область().Защита = Истина;
	ОбщийРезультат = ТекущийЛог;
	Если ЭтоАдресВременногоХранилища(АдресРезультата) Тогда
		
		ОбщийРезультат = ПолучитьИзВременногоХранилища(АдресРезультата);
		
		Если ТипЗнч(ОбщийРезультат) = Тип("ТабличныйДокумент") Тогда
			ОбщийРезультат.Вывести(ТекущийЛог);
		Иначе
			ОбщийРезультат = ТекущийЛог;
		КонецЕсли;	
		
	КонецЕсли;
	
	ПараметрыСеанса.РезультатОтладки = ПоместитьВоВременноеХранилище(ОбщийРезультат, Новый УникальныйИдентификатор);

КонецПроцедуры

// Функция проверяет, разрешена ли отладка 
//
// Параметры: нет
//
// Возвращаемое значение:
//    Булево
//
Функция ОтладкаРазрешена() Экспорт 
	
	Возврат Истина;
	
	//Возврат ПолныеПрава.РежимОтладки();
	
КонецФункции

// Функция выводит значение запроса в табличный документ 
//
// Параметры: 
//   Запрос - переданный запрос
//   ИмяСекции  - имя секции табличного документа, в которую осуществляется вывод
//
// Возвращаемое значение:
//    ТДРезультатаЗапроса - табличный документ с результатом запроса
//
Функция ЗначениеЗапроса(Запрос, ИмяСекции)
	
	ТДРезультатаЗапроса = Новый ТабличныйДокумент;
	
	Макет = ПолучитьОбщийМакет("Отладка");
	
	ОбластьЗаголовка 						= Макет.ПолучитьОбласть("Заголовок");
	ОбластьЗаголовка.Параметры.ИмяТаблицы 	= ИмяСекции;
	ОбластьЗаголовка.Параметры.ОбъектОтладки = "Запрос"; 

	ТДРезультатаЗапроса.Вывести(ОбластьЗаголовка);
	
	ОбластьПараметров 	= Макет.ПолучитьОбласть("ПараметрыЗапроса");
	
	ПараметрыЗапроса = Новый Массив;
	Для Каждого текПараметр из Запрос.Параметры Цикл
		
		СтруктураПараметра = Новый Структура("Имя, Значение", текПараметр.Ключ, ЗначениеВСтрокуВнутр(текПараметр.Значение));
		ПараметрыЗапроса.Добавить(СтруктураПараметра);
		
//{NFO-1337
		ЗначениеПараметра =  текПараметр.Значение;
		Если ТипЗнч(ЗначениеПараметра) = Тип("Граница") Тогда
			ЗначениеПараметра = "" + ЗначениеПараметра.Значение + ", " + ЗначениеПараметра.ВидГраницы;			
		КонецЕсли; 
//}NFO-1337		
		
		ОбластьПараметров = Макет.ПолучитьОбласть("ПараметрыЗапроса");
		ОбластьПараметров.Параметры.Имя 		= текПараметр.Ключ;
		ОбластьПараметров.Параметры.Значение 	= ЗначениеПараметра;
		ОбластьПараметров.Параметры.ЗначениеРасшифровки = РасшифровкаЗначения(текПараметр.Значение);
		
		ТДРезультатаЗапроса.Вывести(ОбластьПараметров);
		
	КонецЦикла;
	
//{NFO-1337
	ОбластьПараметров = Макет.ПолучитьОбласть("ПараметрыЗапроса");
	ОбластьПараметров.Параметры.Имя 		= "Текст запроса";
	ОбластьПараметров.Параметры.Значение 	= СокрЛП(Запрос.Текст);
	ОбластьПараметров.Параметры.ЗначениеРасшифровки = РасшифровкаЗначения(СокрЛП(Запрос.Текст));
	
	ТДРезультатаЗапроса.Вывести(ОбластьПараметров);

	ОбластьТекстЗапроса = ТДРезультатаЗапроса.НайтиТекст(СокрЛП(Запрос.Текст));
	ОбластьТекстЗапроса.РазмещениеТекста = ТипРазмещенияТекстаТабличногоДокумента.Обрезать;
	ОбластьТекстЗапроса.ВысотаСтроки = 12;
	ОбластьТекстЗапроса.ВертикальноеПоложение = ВертикальноеПоложение.Верх;
//}NFO-1337	

	ПараметрыВыводаЗапроса = Новый Структура;
	ПараметрыВыводаЗапроса.Вставить("ВыводитьВременныеТаблицы", Истина);
	ПараметрыВыводаЗапроса.Вставить("ВыводитьИдентификатор",    Ложь);
	ПараметрыВыводаЗапроса.Вставить("ПорядокОбхода",            "Авто");
	ПараметрыВыводаЗапроса.Вставить("ИспользованиеЧередования", Истина);
	
	ОтчетПоВыполнениюЗапроса = Новый Структура;
	ОтчетПоВыполнениюЗапроса.Вставить("ВремяВыполнения", 0);
	ОтчетПоВыполнениюЗапроса.Вставить("КоличествоСтрок", 0);
	ОтчетПоВыполнениюЗапроса.Вставить("ТекстСообщения",  "");
	
	КонсольЗапросов = Обработки.КонсольЗапросовДляЛогаОтладки.Создать();
	Результат = КонсольЗапросов.ВыполнитьЗапрос(Запрос.Текст, ПараметрыЗапроса, ТДРезультатаЗапроса, ПараметрыВыводаЗапроса, ОтчетПоВыполнениюЗапроса, "", Запрос);
	Если Результат = Неопределено Тогда
		ОбластьОписаниеОшибки = Макет.ПолучитьОбласть("ОписаниеОшибки");
		ОбластьОписаниеОшибки.Параметры.ОписаниеОшибки = ОтчетПоВыполнениюЗапроса.ТекстСообщения;
		ТДРезультатаЗапроса.Вывести(ОбластьОписаниеОшибки);
	КонецЕсли;

	
	Возврат ТДРезультатаЗапроса;
	
КонецФункции

// Функция выводит таблицу значений в табличный документ 
//
// Параметры: 
//   ТЗ - переданная таблица значений
//   ИмяСекции  - имя секции табличного документа, в которую осуществляется вывод
//
// Возвращаемое значение:
//    ТабДок - табличный документ
//
Функция ЗначениеТаблицыЗначенийДереваЗначений(ТаблицаДерево, ИмяСекции)
	
	Если ТипЗнч(ТаблицаДерево) = Тип("ТаблицаЗначений") Тогда
		КоличествоСтрок = ТаблицаДерево.Количество();
		ТипОбъекта = "Таблица значений";
	ИначеЕсли ТипЗнч(ТаблицаДерево) = Тип("ДеревоЗначений") Тогда
		КоличествоСтрок = ТаблицаДерево.Строки.Количество();
		ТипОбъекта = "Дерево значений";
	КонецЕсли;
	
	ТабличныйДокумент = Новый ТабличныйДокумент;
	Макет = ПолучитьОбщийМакет("Отладка");
	
	ОбластьЗаголовка 						 = Макет.ПолучитьОбласть("ЗаголовокТаблицы");
	ОбластьЗаголовка.Параметры.ИмяТаблицы 	 = "" + ИмяСекции;
	ОбластьЗаголовка.Параметры.ОбъектОтладки = ТипОбъекта; 
	ТабличныйДокумент.Вывести(ОбластьЗаголовка);
	
	ПараметрыВывода = Новый Структура;
	ПараметрыВывода.Вставить("ИспользованиеЧередования", Истина);
	ПараметрыВывода.Вставить("ВыводитьИдентификатор",    Ложь);
	
	КонсольЗапросов = Обработки.КонсольЗапросовДляЛогаОтладки.Создать();
	Результат = КонсольЗапросов.ВывестиРезультатТаблицыДерева(ТипОбъекта, КоличествоСтрок, Новый Массив, Истина, ПараметрыВывода, ТаблицаДерево);
	ТабличныйДокумент.Вывести(Результат);
	
	Возврат ТабличныйДокумент;
	
КонецФункции

// Функция выводит табличный в табличный документ 
//
// Параметры: 
//   ОбъектОтладки - Табличный документ
//   ИмяСекции  - имя секции табличного документа, в которую осуществляется вывод
//
// Возвращаемое значение:
//    ТабДок - табличный документ
//
Функция ЗначениеТабличногоДокуммента(ОбъектОтладки, ИмяСекции)
	
	ТабличныйДокумент = Новый ТабличныйДокумент;
	Макет = ПолучитьОбщийМакет("Отладка");
	
	ОбластьЗаголовка = Макет.ПолучитьОбласть("ЗаголовокТаблицы");
	ОбластьЗаголовка.Параметры.ИмяТаблицы = ИмяСекции;
	ОбластьЗаголовка.Параметры.ОбъектОтладки = "Табличный документ"; 
	ТабличныйДокумент.Вывести(ОбластьЗаголовка);
	
	ТабличныйДокумент.Вывести(ОбъектОтладки);
	
	Возврат ТабличныйДокумент;
	
КонецФункции

// Функция выводит строку текста в табличный документ 
//
// Параметры: 
//   СтрокаТекста - переданная строка текста
//   ИмяСекции  - имя секции табличного документа, в которую осуществляется вывод
//
// Возвращаемое значение:
//    ТабДок - табличный документ
//
Функция ЗначениеТекстовогоПоля(СтрокаТекста, ИмяСекции)
		
	ТабличныйДокумент = Новый ТабличныйДокумент;
	Макет = ПолучитьОбщийМакет("Отладка");
	
	ОбластьЗаголовка 						 = Макет.ПолучитьОбласть("ЗаголовокТаблицы");
	ОбластьЗаголовка.Параметры.ИмяТаблицы 	 = "" + ИмяСекции;
	ОбластьЗаголовка.Параметры.ОбъектОтладки = "Строка текста"; 
	ТабличныйДокумент.Вывести(ОбластьЗаголовка);
	
	ОбластьТекста = Макет.ПолучитьОбласть("ОбластьТекстаЛога");
	ОбластьТекста.Параметры.ТекстЛога = СтрокаТекста; 
	ТабличныйДокумент.Вывести(ОбластьТекста);

	Возврат ТабличныйДокумент;
	
КонецФункции

// Функция получает системное строковое представление переданной таблицы значений
//
// Параметры: 
//   Значение - переданная таблица значений
//
// Возвращаемое значение:
//    Значение - системное строковое представление переданной таблицы значений или исходное занчение
//
Функция РасшифровкаЗначения(Значение)
	
	Если ТИПЗНЧ(Значение) = Тип("ТаблицаЗначений") тогда
		Возврат ЗначениеВСтрокуВнутр(Значение);
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции

// Процедура очищает параметр сеанса РезультатОтладки
//
// Параметры: нет
//
Процедура ОчиститьРезультатОтладки()Экспорт
	
	ПараметрыСеанса.РезультатОтладки = "";
	
КОнецПроцедуры

// Обработчик события ПриЗаписи для справочников, хранящих сведения о Активах
//	См. также  подпискиНаСобытия.СинхронизацияАктивов
//
// Входные параметры:
//  Источник - источник, для которого необходимо обновить информацию об активе
//  Отказ - признак отказа
//
Процедура ОбновитьАктив(Источник, Отказ) Экспорт
	
	СтруктураПараметров = Новый Структура("Источник, ЭтоНовый, РодительАктива", Источник.Ссылка, Источник.ЭтоНовый(), Источник.РодительАктива);
	
	СтруктураПараметров.Вставить("ОбменДаннымиЗагрузка", Источник.ОбменДанными.Загрузка);
	
	//ПолныеПрава.ОбновитьАктив_Служебная(СтруктураПараметров, Отказ);
	
КонецПроцедуры // ОбновитьАктив()

// Функция возвращает строку для разделителя запросов пакета
//
// Параметры: нет
//
// Возвращаемое значение:
//  ТекстРазделителя - строковое значение для разделителя запросов пакета
Функция ТекстРазделителяЗапросовПакета() Экспорт
	
	ТекстРазделителя = 
	"
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|";
	
	Возврат ТекстРазделителя;
	
КонецФункции

Процедура ДобавитьДекорациюАвтор(Форма) Экспорт
	
	Если Форма.Элементы.Найти("ГруппаКомментарий") <> Неопределено Тогда
		Родитель = Форма.Элементы.ГруппаКомментарий;
	Иначе
		Родитель = Форма;
	КонецЕсли;
	ДекорацияАвтор = Форма.Элементы.Добавить("ДекорацияАвтор", Тип("ДекорацияФормы"), Родитель);
	ДекорацияАвтор.Заголовок = НСтр("en = 'Author: '; ru = 'Автор: '") + Форма.Объект.Автор;

КонецПроцедуры	

Процедура ДобавитьРеквизитыПереопределяемый(Форма, ИмяОбъекта) Экспорт
	
	

КонецПроцедуры	

Функция НайтиЭлементСправочникаПоРеквизиту(ЗначениеРеквизита, ИмяСправочника, ИмяРеквизита) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Банки.Ссылка
		|ИЗ
		|	Справочник.Банки КАК Банки
		|ГДЕ
		|	Банки.ПометкаУдаления = ЛОЖЬ
		|	И Банки.Код = &ЗначениеРеквизита";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "Банки", ИмяСправочника);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "Код", ИмяРеквизита);
	
	ЗначениеРеквизитаДляПоиска = ?(ТипЗнч(ЗначениеРеквизита) = Тип("Строка"), СокрЛП(ЗначениеРеквизита), ЗначениеРеквизита);
	
	Запрос.УстановитьПараметр("ЗначениеРеквизита", ЗначениеРеквизитаДляПоиска);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ОбщегоНазначенияДУ.ДобавитьВЛогОтладки(Запрос, "ОбщегоНазначенияДУ.НайтиЭлементСправочникаПоРеквизиту");
	
	Выборка = РезультатЗапроса.Выбрать();
	
	Если Выборка.Следующий() Тогда
		Возврат Выборка.Ссылка;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

Функция НайтиЭлементСправочникаПоУИД(СтрокаУИД, ИмяСправочника) Экспорт
	
	НайденныйЭлемент = Неопределено;
	
	Если СтрокаУИД <> Неопределено И ЗначениеЗаполнено(СтрокаУИД) Тогда
		
		Попытка
			
			УИД = Новый УникальныйИдентификатор(СтрокаУИД);
			
			ЭлементБазы = Справочники[ИмяСправочника].ПолучитьСсылку(УИД);
			
			Если Не Найти(Строка(ЭлементБазы), "Объект не найден") Тогда
				НайденныйЭлемент = ЭлементБазы;
			КонецЕсли;
			
		Исключение
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат НайденныйЭлемент;
	
КонецФункции

Процедура ДобавитьОтборВПостроитель(ИмяОтбора, ЗначениеОтбора, Построитель) Экспорт
	
	Если Построитель.Отбор.Найти(ИмяОтбора) = Неопределено Тогда 
		Построитель.Отбор.Добавить(ИмяОтбора);	
	КонецЕсли; 
		
	ЗаполнитьЗначенияСвойств(Построитель.Отбор[ИмяОтбора], 
		Новый Структура("ВидСравнения, Значение, Использование", 
			ВидСравнения.Равно, 
			ЗначениеОтбора, 
			Истина));
	
КонецПроцедуры

Функция ДатаИзСтроки(ДатаСтрокой) Экспорт
	
	ПреобразованнаяДата = '00010101';
	
	Если ПустаяСтрока(ДатаСтрокой) Тогда
		Возврат ПреобразованнаяДата;
	КонецЕсли;
	
	// Формат ДД.ММ.ГГ
	Если СтрДлина(ДатаСтрокой) = 8 тогда
		Попытка
			ПреобразованнаяДата = Дата("20" + Прав(ДатаСтрокой, 2), Сред(ДатаСтрокой, 4, 2),Лев(ДатаСтрокой, 2));	
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	// Формат ДД.ММ.ГГГГ
	Если СтрДлина(ДатаСтрокой) = 10 тогда
		Попытка
			ПреобразованнаяДата = Дата(Прав(ДатаСтрокой, 4), Сред(ДатаСтрокой, 4, 2),Лев(ДатаСтрокой, 2));	
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	Возврат ПреобразованнаяДата;
	
КонецФункции

Процедура УдалитьКлючИзСтруктуры(Структура, Ключ) Экспорт

	Если ТипЗнч(Структура) = Тип("Структура") И Структура.Свойство(Ключ) Тогда
		Структура.Удалить(Ключ);
	КонецЕсли; 

КонецПроцедуры


// ОБЩИЕ ПРОЦЕДУРЫ И ФУНКЦИИ ОТНОСЯШИЕСЯ К РЕГЛАМЕНТНЫМ ОПЕРАЦИЯМ

#Область ОБЩИЕ_ПРОЦЕДУРЫ_И_ФУНКЦИИ_ОТНОСЯШИЕСЯ_К_РЕГЛАМЕНТНЫМ_ОПЕРАЦИЯМ

// Функция проверяет входит ли документ в план регламентных операций
//
//Параметры:
//  Ссылка - ДокументСсылка.НачислениеКупонногоДохода
//  Основание - ДокументСсылка.ПланРегламентныхОперацийДУ
//
//Возвращаемое значение:
// <Булево>  Истина - входит, Ложь - нет.
Функция ДокументВходитвПланРеглОпераций(Основание) Экспорт
	
    Возврат ЗначениеЗаполнено(Основание) И ТипЗнч(Основание) = Тип("ДокументСсылка.ПланРегламентныхОперацийДУ"); 
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ УПРАВЛЕНИЯ НОМЕРАМИ ДОКУМЕНТОВ

// Процедура используется для добавления к порядковому номеру документа 
// префикса договора доверительного управления  
//
// Параметры: 
//   ДокументОбъект - документ объект
//   Префикс  - префикс договора ДУ
//
// Возвращаемое значение:
// Если  нет реквизита "Портфель" или для него не задан префикс, то 
// используем пустой префикс,
// иначе используем префикс договора ДУ.
//
Процедура ДобавитьПрефиксПортфеля(ДокументОбъект, Префикс) Экспорт
	
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	Если Не ЕстьРеквизитДокумента("Портфель", МетаданныеДокумента)
		ИЛИ НЕ ЗначениеЗаполнено(ДокументОбъект.Портфель.Префикс)  Тогда
		Префикс = "0";
	Иначе
		
		Префикс = ДокументОбъект.Портфель.Префикс;
		
	КонецЕсли;
Конецпроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОВЕРКИ НАЛИЧИЯ И ЗАПОЛНЕНИЯ РЕВИЗИТОВ

// Позволяет определить есть ли среди реквизитов шапки документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента) Экспорт
	
	Возврат НЕ (МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) = Неопределено);
	
КонецФункции // ЕстьРеквизитДокумента()

// Позволяет определить есть ли табличная часть документа с переданным именем.
//
// Параметры: 
//  ИмяТабЧасти - строковое имя искомой табличной части,
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьТабЧастьДокумента(ИмяТабЧасти, МетаданныеДокумента) Экспорт
	
	Если МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 
	
КонецФункции // ЕстьТабЧастьДокумента()

// Позволяет определить есть ли среди реквизитов табличной части документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - строковое имя табличной части документа, среди реквизитов которого производится поиск
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиДокумента(ИмяРеквизита, МетаданныеДокумента, ИмяТабЧасти) Экспорт
	
	ТабЧасть = МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти);
	
	Если ТабЧасть = Неопределено Тогда // Нет такой таб. части в документе
		Возврат Ложь;
		
	Иначе
		Возврат НЕ (ТабЧасть.Реквизиты.Найти(ИмяРеквизита) = Неопределено);
		
	КонецЕсли;
	
КонецФункции // ЕстьРеквизитТабЧастиДокумента()

// Позволяет определить есть ли незаполненный реквизит среди реквизитов шапки документа
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита,
//  ДокументОбъект - документ объект
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли незаполненный реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьНезаполненныйРеквизитДокумента(ИмяРеквизита, ДокументОбъект, МетаданныеДокумента) Экспорт
	
	Результат =
	ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента) 
	И НЕ ЗначениеЗаполнено(ДокументОбъект[ИмяРеквизита]);
	
	Возврат Результат;
	
КонецФункции

// Позволяет определить есть ли незаполненный реквизит среди реквизитов табличной части документа
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  СтрокаТабЧасти - строка табличной части,
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - строковое имя табличной части документа, среди реквизитов которого производится поиск
//
// Возвращаемое значение:
//  Истина - нашли незаполненный реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьНезаполненныйРеквизитТабЧастиДокумента(ИмяРеквизита, СтрокаТабЧасти, МетаданныеДокумента, ИмяТабЧасти) Экспорт
	
	Результат = 
	ЕстьРеквизитТабЧастиДокумента(ИмяРеквизита, МетаданныеДокумента, ИмяТабЧасти) 
	И НЕ ЗначениеЗаполнено(СтрокаТабЧасти[ИмяРеквизита]);
	
	Возврат Результат;
	
КонецФункции

// Выполняет установку отбора по указанному портфелю, управляющей компании в динамических списках. 
// Вызывать необходимо из обработчика формы ПриСозданииНаСервере. 
//
// Параметры
//  Форма          - УправляемаяФорма  - форма, в которой необходимо установить отбор
//  ИмяСписка      - Строка - имя реквизита формы типа ДинамическийСписок.
//  ИмяРеквизита   - Строка - имя поля-организации в динамическом списке.              
//  ЗначениеОтбора - СправочникСсылка.Организации, СписокЗначений, Массив - значение отбора.
//                   Если значение не задано, то будет подставлена основная организация из 
//                   настроек пользователя.
//
// Возвращаемое значение:
//   СправочникСсылка.ДУ_Портфели - Если отбор установлен, то вернет значение отбора.
//
Функция УстановитьОтборПоОсновномуПортфелю(Форма, ИмяСписка = "Список", ИмяРеквизита = "Портфель", ЗначениеОтбора = Неопределено) Экспорт
	
	Если Не Форма.Параметры.Отбор.Свойство(ИмяРеквизита) Тогда		
		Если ЗначениеОтбора = Неопределено Тогда
			Если ЗначениеЗаполнено(ПараметрыСеанса.ОсновнойПортфель) Тогда // XG-726
				ЗначениеОтбора = ПараметрыСеанса.ОсновнойПортфель; // XG-726
			Иначе 
				Возврат Неопределено;
			КонецЕсли;
		КонецЕсли;
		
		ВидСравненияОтбора = ВидСравненияКомпоновкиДанных.Равно;
		Представление = НСтр("ru = 'Отбор по основному портфелю (%1)'");
		
		Если ИмяРеквизита = "Организация" Или ИмяРеквизита = "УправляющаяКомпания" Тогда
			ЗначениеОтбора = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ЗначениеОтбора, "УправляющаяКомпания");
			Представление = НСтр("ru = 'Отбор по основномой управляющей компании (%1)'");
		КонецЕсли;
		Представление = СтрШаблон(Представление, Строка(ЗначениеОтбора));
		
		ОтборыСписковКлиентСервер.УстановитьЭлементОтбораСпискаСВозможностьюРедактирования(Форма[ИмяСписка], ИмяРеквизита, 
			ЗначениеОтбора, ВидСравненияОтбора, Представление);
		
		Возврат ЗначениеОтбора;
		
	КонецЕсли;
	
КонецФункции

// Выполняет установку отбора по указанному портфелю, управляющей компании в отчетах. 
// Вызывать необходимо из обработчика формы ПриСозданииНаСервере. 
//
// Параметры
//
// Возвращаемое значение:
//   СправочникСсылка.ДУ_Портфели - Если отбор установлен, то вернет значение отбора.
//
Функция УстановитьОтборПоОсновномуПортфелюВОтчетах(ЗначениеОтбора = Неопределено) Экспорт  // XG-726
	
	Возврат Справочники.Портфели.ПустаяСсылка();
	
	//Если ЗначениеЗаполнено(ПараметрыСеанса.ОсновнойПортфель) Тогда 
	//	
	//	Если ЗначениеОтбора = Неопределено Тогда
	//		ЗначениеОтбора = ПараметрыСеанса.ОсновнойПортфель;
	//	ИначеЕсли ТипЗнч(ЗначениеОтбора) = Тип("СписокЗначений") Тогда
	//		ЗначениеОтбора.Добавить(ПараметрыСеанса.ОсновнойПортфель);
	//	КонецЕсли;
	//	
	//Иначе 
	//	Возврат Справочники.ДУ_Портфели.ПустаяСсылка();
	//КонецЕсли;
	//                                                       
	//Возврат ЗначениеОтбора;
	
КонецФункции

// Выполняет установку реквизитов в указаном документе 
//
// Параметры:
//
// УстанавливаемыеРеквизиты - Тип: Произвольный. 
// Внимание! Значение данного параметра не может быть следующих типов: Неопределено, Null, Число, Строка, Дата, Булево. 
// 
// ИмяДокумента - Строка, Наименование документа в конфигурации 
//
// Отбор - Соответствие, Дополнительный отбор
//
Процедура УстановитьРеквизитыВоВсехДокументах(ИмяДокумента, УстанавливаемыеРеквизиты, Отбор = Неопределено, ПроводитьДокументы = Ложь) Экспорт
	                                                                                                                           
		Запрос = Новый Запрос;
		Запрос.Текст = 
			"ВЫБРАТЬ
			|	" + ИмяДокумента + ".Ссылка
			|ИЗ
			|	Документ." + ИмяДокумента + " КАК " + ИмяДокумента + "";
		
		Если Отбор <> Неопределено Тогда
			Запрос.Текст = Запрос.Текст + " ГДЕ ";
			ТекстОтбора = "";
			Для Каждого КлючЗначение Из Отбор Цикл
				Запрос.УстановитьПараметр(КлючЗначение.Ключ, КлючЗначение.Значение);
				ТекстОтбора = ТекстОтбора + ?(ТекстОтбора = "", "", " И ") + СтрШаблон(ИмяДокумента + ".%1 = &%1", КлючЗначение.Ключ);
			КонецЦикла;
			Запрос.Текст = Запрос.Текст + ТекстОтбора;
		КонецЕсли;
		
		Выборка = Запрос.Выполнить().Выбрать();
		
		Пока Выборка.Следующий() Цикл
			ДокументОбъект = Выборка.Ссылка.ПолучитьОбъект();
			ДокументОбъект.ОбменДанными.Загрузка = Истина;
			ДокументОбъект.ДополнительныеСвойства.Вставить("ПропуститьПроверкуЗапретаИзменения", Истина);
			ЗаполнитьЗначенияСвойств(ДокументОбъект, УстанавливаемыеРеквизиты);
			Попытка
				ДокументОбъект.Записать(РежимЗаписиДокумента.Запись);
			Исключение
				ЗаписьЖурналаРегистрации("Ошибка записи документа " + Выборка.Ссылка + " во время обновления", УровеньЖурналаРегистрации.Ошибка, Выборка.Ссылка.Метаданные(), Выборка.Ссылка, ОписаниеОшибки());
			КонецПопытки;
			ДокументОбъект.ОбменДанными.Загрузка = Ложь;
			Если ПроводитьДокументы И ДокументОбъект.Проведен Тогда
				Попытка
					ДокументОбъект.Записать(РежимЗаписиДокумента.Проведение);
				Исключение
					ЗаписьЖурналаРегистрации("Ошибка проведения документа " + Выборка.Ссылка + " во время обновления", УровеньЖурналаРегистрации.Ошибка, Выборка.Ссылка.Метаданные(), Выборка.Ссылка, ОписаниеОшибки());
				КонецПопытки;
			КонецЕсли;
		КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ВАЛЮТАМИ

// Функция определяет курс документа, который равен либо курсу документа (если в документе он существует),
// либо  курсу взаиморасчетов, либо 1.
//
// Параметры:
//  ДокументОбъект                 - объект документа, курс которого надо получить
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//
// Возвращаемое значение:
//  Число - курс документа.
//
Функция КурсДокумента(ДокументОбъект, ВалютаРегламентированногоУчета) Экспорт
	
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента) Тогда
		// Если валюта документа совпадает с валютой регл. учета, то курс 1.
		Если (ЗначениеЗаполнено(ДокументОбъект.ВалютаДокумента)) И (ДокументОбъект.ВалютаДокумента <> ВалютаРегламентированногоУчета) Тогда
			
			МетаданныеДокумента = ДокументОбъект.Метаданные();
			
			// Если есть реквизит КурсДокумента - его и вернем
			Если ЕстьРеквизитДокумента("КурсДокумента", МетаданныеДокумента) Тогда
				Возврат ДокументОбъект.КурсДокумента;
			КонецЕсли;
			
			// Если нет КурсДокумента и валюта документа не совпадает с валютой регл. учета,
			// то такой документ может быть  выписан только в валюте взаиморасчетов,
			// если есть реквизит КурсВзаиморасчетов - его и вернем.
			Если ЕстьРеквизитДокумента("КурсВзаиморасчетов", МетаданныеДокумента) Тогда
				Возврат ДокументОбъект.КурсВзаиморасчетов;
			КонецЕсли;
			
			// Если нет КурсВзаиморасчетов и валюта документа не совпадает с валютой регл. учета,
			// то КурсВзаиморасчетов  долежн быть в табличной части документа или может вообще отсутсвовать.
			// Тогда возьмем курс из справочника на дату документа.
			Если ЕстьРеквизитДокумента("Портфель", МетаданныеДокумента) Тогда
				Возврат МодульВалютногоУчета.ПолучитьКурсВалютыПоПортфелю(ДокументОбъект.Портфель, ДокументОбъект.ВалютаДокумента, ДокументОбъект.Дата).Курс;
			Иначе
				Возврат МодульВалютногоУчета.ПолучитьКурсВалюты(Неопределено, ДокументОбъект.ВалютаДокумента, ДокументОбъект.Дата).Курс;
			КонецЕсли;			
		КонецЕсли;
	КонецЕсли;
	
	Возврат 1;
	
КонецФункции // КурсДокумента()

// Функция определяет кратность документа, которая равен либо кратности документа (если в документе она  существует),
// либо кратности взаиморасчетов, либо 1.
//
// Параметры:
//  ДокументОбъект - объект документа, курс которого надо получить
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//
// Возвращаемое значение:
//  Число - кратность валюты в документе.
//
Функция КратностьДокумента(ДокументОбъект, ВалютаРегламентированногоУчета) Экспорт
	
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента) Тогда
		// Если валюта документа совпадает с валютой регл. учета, то кратность 1.
		Если (ЗначениеЗаполнено(ДокументОбъект.ВалютаДокумента)) И (ДокументОбъект.ВалютаДокумента <> ВалютаРегламентированногоУчета) Тогда
			
			// Если есть реквизит КратностьДокумента - его и вернем
			Если ЕстьРеквизитДокумента("КратностьДокумента", МетаданныеДокумента) Тогда
				Возврат ДокументОбъект.КратностьДокумента;
			КонецЕсли;
			
			// Если нет КратностьДокумента и валюта документа не совпадает с валютой регл. учета,
			// то такой документ может  быть выписан только в валюте взаиморасчетов,
			// если есть реквизит КратностьВзаиморасчетов - его и вернем.
			Если ЕстьРеквизитДокумента("КратностьВзаиморасчетов", МетаданныеДокумента) Тогда
				Возврат ДокументОбъект.КратностьВзаиморасчетов;
			КонецЕсли;
			
			// Если нет КратностьВзаиморасчетов и валюта документа не совпадает с валютой регл. учета,
			// то  КратностьВзаиморасчетов должна быть в табличной части документа или может вообще отсутсвовать.
			//Тогда возьмем Кратность из справочника на дату документа.
			Если ЕстьРеквизитДокумента("Портфель", МетаданныеДокумента) Тогда
				Возврат МодульВалютногоУчета.ПолучитьКурсВалютыПоПортфелю(ДокументОбъект.Портфель, ДокументОбъект.ВалютаДокумента, ДокументОбъект.Дата).Кратность;
			Иначе
				Возврат МодульВалютногоУчета.ПолучитьКурсВалюты(Неопределено, ДокументОбъект.ВалютаДокумента, ДокументОбъект.Дата).Кратность;
			КонецЕсли			
		КонецЕсли;
	КонецЕсли;
	
	Возврат 1;
	
КонецФункции // КратностьДокумента()

// Функция возвращает валюту регламентированного учета по Договору ДУ или из параметра сеанса ВалютаРегл
//
// Параметры:
//  Договор - переданный Портфель, по умолчанию Неопределено
//
// Возвращаемое значение:
//   валюта портфеля или валюта параметра сеанса ВалютаРеглУчета
//
Функция ВалютаРеглУчета(Портфель = Неопределено) Экспорт
	
	ВалютаУчета = УА_ПривилегированныйСервер.ВалютаРеглУчета();
			
	Возврат ВалютаУчета;	
	
КонецФункции // ВалютРеглУчета

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С  ДВИЖЕНИЯМИ ДОКУМЕНТОВ

// Процедура удаляет движения документа по указанному регистру либо по всем регистрам.
//
// Параметры:
//   Движения	- коллекция движений документа.
//  ИмяРегистра - имя регистра, движения по которому будут удалены;
//				необязательный, если не указан - удаляются все движения.
//
Процедура УдалитьДвиженияДокумента(Движения, ИмяРегистра = "") Экспорт
	
	Если ИмяРегистра = "" Тогда
		Для Каждого ДвиженияРегистра Из Движения Цикл
			ДвиженияРегистра.Очистить();
		КонецЦикла;
	Иначе
		Движения[ИмяРегистра].Очистить();
	КонецЕсли;
	
КонецПроцедуры // УдалитьДвиженияДокумента()

// Процедура удаления существующих движений документа при перепроведении 
// (отмене проведения)
//
//Параметры:
//  ДокументОбъект - объект документ, 
//  Отказ - флаг отказа от выполнения процедуры, 
//  РучнаяКорректировка -  флаг использования ручной корректировки, по умолчанию Ложь, 
//  ВыборочноОчищатьРегистры  - флаг выборочного очищения регистров, по умолчанию Ложь
//
Процедура УдалитьДвиженияРегистратора(ДокументОбъект, Отказ, РучнаяКорректировка = Ложь, ВыборочноОчищатьРегистры = Ложь) Экспорт
	
	Если РучнаяКорректировка Тогда
		ИзменитьАктивностьПоРегистратору(ДокументОбъект, Отказ, Ложь);
		возврат;
	КонецЕсли;
	
	Если ВыборочноОчищатьРегистры Тогда
		СписокРегистровДляОчисткиДвижений = Новый Массив;
	КонецЕсли;
	
	//Очистка движений документа
	Для Каждого Движение ИЗ ДокументОбъект.Движения Цикл
		
		Если ВыборочноОчищатьРегистры И (СписокРегистровДляОчисткиДвижений.Найти(ТипЗнч(Движение))<>неопределено) Тогда
			Продолжить;
		КонецЕсли;
		Движение.Очистить();
		
	КонецЦикла;
	
	//Запись пустых наборов движений в ИБ(очистка старых движений)	
	Для Каждого Движение ИЗ ДокументОбъект.Движения Цикл
		
		Если (ВыборочноОчищатьРегистры И (СписокРегистровДляОчисткиДвижений.Найти(ТипЗнч(Движение))<>неопределено))
			ИЛИ НЕ ВыборочноОчищатьРегистры Тогда
			
			Если Движение.Количество() > 0 Тогда
				ПозицияТочки = Найти(Строка(Движение), ".");
				ТипРегистра = Лев(Строка(Движение), ПозицияТочки - 13);
				ИмяРегистра = СокрП(Сред(Строка(Движение), ПозицияТочки + 1));
				
				ЕСли ТипРегистра = "РегистрНакопления" Тогда
					МетаданныеНабора = Метаданные.РегистрыНакопления[ИмяРегистра];
					Набор = РегистрыНакопления[ИмяРегистра].СоздатьНаборЗаписей();
					
				ИначеЕсли ТипРегистра = "РегистрБухгалтерии" Тогда
					МетаданныеНабора = Метаданные.РегистрыБухгалтерии[ИмяРегистра];
					Набор = РегистрыБухгалтерии[ИмяРегистра].СоздатьНаборЗаписей();
					
				ИначеЕсли ТипРегистра = "РегистрСведений" Тогда
					МетаданныеНабора = Метаданные.РегистрыСведений[ИмяРегистра];
					Набор = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей();
					
				ИначеЕсли ТипРегистра = "РегистрРасчета" Тогда
					МетаданныеНабора = Метаданные.РегистрыРасчета[ИмяРегистра];
					Набор = РегистрыРасчета[ИмяРегистра].СоздатьНаборЗаписей();
					
				КонецЕсли;
				
				Если НЕ ПравоДоступа("Изменение", МетаданныеНабора) Тогда
					// отсутствуют права на всю таблицу регистра
					ТекстОшибки = НСтр("ru = 'Нарушение прав доступа'");
					ОбщегоНазначенияДУКлиентСервер.СообщитьОбОшибке(ТекстОшибки, Отказ, Строка(Движение));
					Возврат;
				КонецЕсли;
				
				Набор.Отбор.Регистратор.Установить(ДокументОбъект.Ссылка);			
				
			Иначе
				Набор = Движение;
			КонецЕсли;
			
			Попытка
				Набор.Записать();
			Исключение
				// возможно «сработал» RLS или механизм даты запрета изменения
				ОбщегоНазначенияДУКлиентСервер.СообщитьОбОшибке(ОписаниеОшибки(), Отказ, Набор);
				ТекстОшибки = НСтр("ru = 'Операция не выполнена'");
				ВызватьИсключение ТекстОшибки;
			КонецПопытки;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Процедура включения активности движений при проведении документа, движения которого
// заданы вручную
//
//Параметры:
//  ДокументОбъект - объект документ, 
//  Отказ - флаг отказа от выполнения процедуры, 
//  ВключитьАктивность -  флаг включения активности, по умолчанию Истина, 
//
Процедура ИзменитьАктивностьПоРегистратору(ДокументОбъект, Отказ, ВключитьАктивность = Истина) Экспорт
	
	Для Каждого Набор ИЗ ДокументОбъект.Движения Цикл
		
		Набор.Прочитать();
		Набор.УстановитьАктивность(ВключитьАктивность);
		
		Попытка
			Набор.Записать();
		Исключение
			// возможно «сработал» RLS или механизм даты запрета изменения
			ОбщегоНазначенияДУКлиентСервер.СообщитьОбОшибке(ОписаниеОшибки(), Отказ, Набор.Имя);
			ТекстОшибки = НСтр("ru = 'Операция не выполнена'");
			ВызватьИсключение ТекстОшибки;
		КонецПопытки;	
		
	КонецЦикла;	
	
КонецПроцедуры

// Функция формирует структуру, содержащую значения реквизитов шапки документа.
//
// Параметры:
//  ДокументОбъект  - объект документа для формирования структуры шапки,
//
// Возвращаемое значение:
//  Сформированная структура.
//
Функция СформироватьСтруктуруШапкиДокумента(ДокументОбъект) Экспорт
	
	// Первоначальные данные о документе.
	СтруктураШапкиДокумента = Новый Структура;
	СтруктураШапкиДокумента.Вставить("Ссылка"		, ДокументОбъект.Ссылка);
	СтруктураШапкиДокумента.Вставить("Регистратор"	, ДокументОбъект.Ссылка);
	
	СтруктураШапкиДокумента.Вставить("Дата",   ДокументОбъект.Дата);
	СтруктураШапкиДокумента.Вставить("Номер",  ДокументОбъект.Номер);
	
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	СтруктураШапкиДокумента.Вставить("ВидДокумента",  МетаданныеДокумента.Имя);
	СтруктураШапкиДокумента.Вставить("ПредставлениеВидаДокумента",  МетаданныеДокумента.Представление());
	
	Для Каждого Реквизит Из МетаданныеДокумента.Реквизиты Цикл
		СтруктураШапкиДокумента.Вставить(Реквизит.Имя, ДокументОбъект[Реквизит.Имя]);
	КонецЦикла;
	
	// Отображение данных о валютах.
	ВалютаРегламентированногоУчета = ОбщегоНазначенияДУ.ВалютаРеглУчета(); 
	СтруктураШапкиДокумента.Вставить("ВалютаРегламентированногоУчета", ВалютаРегламентированногоУчета);
	
	Если СтруктураШапкиДокумента.Свойство("ВалютаДокумента") Тогда
		СтруктураШапкиДокумента.Вставить("КурсДокумента",      КурсДокумента(ДокументОбъект , ВалютаРегламентированногоУчета));
		СтруктураШапкиДокумента.Вставить("КратностьДокумента", КратностьДокумента(ДокументОбъект , ВалютаРегламентированногоУчета));
	КонецЕсли;
	
	Если СтруктураШапкиДокумента.Свойство("Портфель") Тогда
		СтруктураШапкиДокумента.Вставить("Префикс", СтруктураШапкиДокумента.Портфель.Префикс);
	КонецЕсли;
	
	Возврат СтруктураШапкиДокумента;
	
КонецФункции // СформироватьСтруктуруШапкиДокумента()

// Возвращает список обязательных колонок (через запятую), отсутствующих в таблице значений
//
//Параметры:
//	Таблица 			- <ТаблицаЗначений> - проверяемая таблица
//	ОбязательныеКолонки - <Строка> - имена колонок, которые обязательно должны присутствовать в таблице
//
//Возвращаемое значение:
//	<Строка> - имена отсутствующих в таблице колонок через запятую
Функция ПроверитьКолонкиТаблицыЗначений(Таблица, ОбязательныеКолонки)	Экспорт
	
	СтруктураКолонок = Новый Структура(ОбязательныеКолонки);
	КолонкиТаблицы = Таблица.Колонки;
	СтрокаНеНайденных = "";
	
	Для Каждого ОбязательнаяКолонка Из СтруктураКолонок Цикл
		
		Если КолонкиТаблицы.Найти(ОбязательнаяКолонка.Ключ) = Неопределено Тогда
			СтрокаНеНайденных = СтрокаНеНайденных + ?(СтрокаНеНайденных = "", "", ", ") + ОбязательнаяКолонка.Ключ;
		КонецЕсли; 
		
	КонецЦикла; 
	
	Возврат СтрокаНеНайденных;
	
КонецФункции

// Возвращает таблицу параметров проведения 
//
//Параметры:
//	ИсходнаяТаблица	- <ТаблицаЗначений> - проверяемая таблица
//	СписокКолонок  - <Строка> - имена колонок, которые обязательно должны присутствовать в таблице
//
//Возвращаемое значение:
//	если все колонки из переданного списка присутствуют, то возвращается копия исходной таблицы, 
//  содержащая только те колонки, которые есть в списке
//
Функция ПолучитьТаблицуПараметровПроведения(ИсходнаяТаблица, СписокКолонок) Экспорт
	
	Если ИсходнаяТаблица = Неопределено Тогда
		
		Возврат Новый ТаблицаЗначений;
		
	Иначе
		
		ОтсутствующиеКолонки = ПроверитьКолонкиТаблицыЗначений(ИсходнаяТаблица, СписокКолонок);
		Если НЕ ПустаяСтрока(ОтсутствующиеКолонки) Тогда
			ТекстОшибки = НСтр("ru = 'В таблице отсутствуют колонки: '") + ОтсутствующиеКолонки;
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
		
		Возврат ИсходнаяТаблица.Скопировать(, СписокКолонок);
		
	КонецЕсли;
	
КонецФункции

// Процедура распределяет пропорционально сумму по колонке таблицы  
//
// Параметры:
//   РаспределяемаяСумма - распределяемая сумма, 
//   Таблица - исходная таблица, 
//   ИмяКолонки - имя колонки, по которой будет происходить распределение, 
//   ИмяКолонкиБазы - имя колонки базы, по умолчанию пустая строка
//
Процедура РаспределитьСуммуПоКолонкеТаблицы(РаспределяемаяСумма, Таблица, ИмяКолонки, ИмяКолонкиБазы = "") Экспорт
	
	Если РаспределяемаяСумма <> 0 Тогда
		Если ПустаяСтрока(ИмяКолонкиБазы) Тогда
			МассивСтарыхСумм = Таблица.ВыгрузитьКолонку(ИмяКолонки);
		Иначе
			МассивСтарыхСумм = Таблица.ВыгрузитьКолонку(ИмяКолонкиБазы);
		КонецЕсли;
		МассивНовыхСумм = ОбщегоНазначенияДУКлиентСервер.РаспределитьПропорционально(РаспределяемаяСумма, МассивСтарыхСумм);
		Если МассивНовыхСумм <> Неопределено Тогда
			Таблица.ЗагрузитьКолонку(МассивНовыхСумм, ИмяКолонки);
		КонецЕсли;
	Иначе
		Таблица.ЗаполнитьЗначения(0, ИмяКолонки);
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С  ОШИБКАМИ

// Функция формирует строку представления документа для сообщений при проведении.
//
// Параметры
//  Документ -  ссылка на проводимый документ.
//
// Возвращаемое значение
//  Строка с представлением документа.
//
Функция ПредставлениеДокументаПриПроведении(Документ) Экспорт
	
	МетаданныеДокумента = Документ.Метаданные();
	
	ВидОперацииСтр = "";
	
	Если ЕстьРеквизитДокумента("ВидОперации", МетаданныеДокумента) Тогда
		ВидОперацииСтр = " (" + Документ.ВидОперации + ")";
	КонецЕсли;
	
	Возврат "Проведение документа: " + СокрЛП(Документ) + ВидОперацииСтр;
	
КонецФункции // ПредставлениеДокументаПриПроведении()

// Функция формирует строковое представление объекта
//
// Входные параметры:
//  Объект - объект, для которого  необходимо сформировать представление
//  Вид - вид представления
//
// Возвращаемое значение:
//  Представление - строковое представление объекта
//
Функция ПредставлениеОбъекта(Объект, Вид = "", Дата = Неопределено) Экспорт
	
	Представление = "" + Объект;
	ВалютаРегламентированногоУчета = УА_ПривилегированныйСервер.ВалютаРеглУчета();
	
	Если Объект = Неопределено Или Не (Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(Объект)) Или 
		Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(Объект))) Тогда
		
		Возврат Строка(Объект);
	КонецЕсли;
	
	МетаданныеОбъекта = Объект.Метаданные();
	
	Если Не ЕстьДоступКОбъекту(Объект) Тогда
		
		Представление = Строка(Объект);
		
	ИначеЕсли ТипЗнч(Объект) = Тип("СправочникСсылка.БанковскиеСчета") тогда
		Если Вид = "" Тогда
			Представление = ?(НЕ Объект.Банк.Пустая(), "" + Объект.Банк + ", ", "") + " счет № " + Объект.НомерСчета;
		Иначе
			Представление = Объект.Наименование;
		КонецЕсли;;
	ИначеЕсли ТипЗнч(Объект)=тип("СправочникСсылка.Контрагенты") тогда
		Представление = ?(СокрЛП(Объект.НаименованиеСокращенное) = "", ?(СокрЛП(Объект.НаименованиеПолное) = "", Объект.Наименование, Объект.НаименованиеПолное), Объект.НаименованиеСокращенное); 
		
	ИначеЕсли ТипЗнч(Объект)=тип("СправочникСсылка.уа_ФинансовыеИнструменты") тогда
		Представление = Объект.НаименованиеПолное;
		
	ИначеЕсли Метаданные.Документы.Содержит(МетаданныеОбъекта) Тогда
		
		Если Не Объект.Метаданные().Реквизиты.Найти("НаименованиеПолное") = Неопределено тогда
			
			Представление = Объект.НаименованиеПолное;
			
		Иначе
			
			Представление = "" + МетаданныеОбъекта + ": №" + Объект.Номер + " от " + Формат(Объект.Дата, "ДФ=dd.MM.yyyy; ДЛФ=");
			Если ЕстьРеквизитДокумента("ВидОперации", МетаданныеОбъекта) Тогда
				Представление = Представление + " (" + Объект.ВидОперации + ")";
			КонецЕсли;
			
		КонецЕсли;
		
	Иначе
		
		Представление = Строка(Объект);
		
	КонецЕсли;
	
	Возврат Представление;
	
КонецФункции // ПредставлениеОбъекта()

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ФОРМИРОВАНИЯ  ЗАПРОСА К ДОКУМЕНТУ

// Функция по переданной структуре полей формирует запрос по табличной части документа.
//
// Параметры:
//   ДокументОбъект    - объект проводимого документа,
//  ИмяТабличнойЧасти - строка, имя табличной части,
//  СтруктураПолей    - структура, ключ структуры содержит псевдоним поля запроса, значение - строку запроса,
//
// Возвращаемое значение:
//  Результат запроса.
//
Функция СформироватьЗапросПоТабличнойЧасти(ДокументОбъект, ИмяТабличнойЧасти, СтруктураПолей) Экспорт
	
	ТекстЗапроса = "";
	
	Для Каждого Реквизит Из СтруктураПолей Цикл
		
		ТекстЗапроса  = ТекстЗапроса + ",
		|	Док." + Реквизит.Значение + " КАК " + СокрЛП(Реквизит.Ключ);
		
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	Док.НомерСтроки " + ТекстЗапроса + "
	|
	|ИЗ
	|	Документ." + ДокументОбъект.Метаданные().Имя + "."+ СокрЛП(ИмяТабличнойЧасти) + " КАК Док
	|
	|ГДЕ
	|	Док.Ссылка = &ДокументСсылка
	|УПОРЯДОЧИТЬ ПО
	| Док.НомерСтроки";
	
	// Установим параметры запроса.
	Запрос.УстановитьПараметр("ДокументСсылка" , ДокументОбъект.Ссылка);
	
	Возврат Запрос.Выполнить();
	
КонецФункции // СформироватьЗапросПоТабличнойЧасти()

// Функция получает списов счетов  
// 
// Параметры: нет
//
// Возвращаемое значение:
//  СписокСчетов - список значений
//
Функция ПолучитьСписокСчетов() Экспорт 
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	Хозрасчетный.Ссылка КАК Счет
	|ИЗ
	|	ПланСчетов.Хозрасчетный КАК Хозрасчетный
	|		ЛЕВОЕ СОЕДИНЕНИЕ ПланСчетов.Хозрасчетный.ВидыСубконто КАК ХозрасчетныйВидыСубконто
	|		ПО (ХозрасчетныйВидыСубконто.Ссылка = Хозрасчетный.Ссылка)
	|ГДЕ
	|	(НЕ Хозрасчетный.ЗапретитьИспользоватьВПроводках)
	|
	|СГРУППИРОВАТЬ ПО
	|	Хозрасчетный.Ссылка
	|
	|ИМЕЮЩИЕ
	|	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ ХозрасчетныйВидыСубконто.ВидСубконто) = 0";
	
	СписокСчетов = Новый СписокЗначений;		
	Списоксчетов.ЗагрузитьЗначения(Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Счет"));	
	
	Возврат Списоксчетов;
	
КонецФункции // ПолучитьСписокСчетов()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УПРАВЛЯЕМЫМИ БЛОКИРОВКАМИ

// Устанавливает управляемую блокировку таблицы
//
// Параметры:
//  СтруктураПараметров 		- <Структура>. Структура параметров блокировки. Обязательный параметр.
//								Обязательно должна содержать свойства:
//								"ИмяТаблицы" - <Строка> - имя таблицы, на которую накладывается блокировка.
//									Например: "АвансовыйОтчет"
//								Необязательные свойства:
//								"ТипТаблицы" - <Строка> - тип таблицы, на которую накладывается блокировка.
//									Пространство блокировки состоит из типа таблицы и имени таблицы.
//									Например: "Документ"
//									Значение по умолчанию: "РегистрНакопления"
//								"РежимБлокировки" - <РежимБлокировкиДанных> - режим накладываемой блокировки.
//									Значение по умолчанию: РежимБлокировкиДанных.Исключительный
//								"ИсточникДанных" - источник данных для блокировки.
//									Может передаваться значение любого типа, поддерживаемого свойством ИсточникДанных элемента блокировки,
//									а также типа "Менеджер временных таблиц".
//									Если в структуре нет этого свойства - блокировки через ИспользоватьИзИсточникаДанных() не накладываются.
//								"ИмяВременнойТаблицы" - <Строка> - имя временной таблицы менеджера временных таблиц, которая служит источником данных для блокировки.
//									Обязательно должно указываться, если в качестве источника данных процедуре передан менеджер временных таблиц.
//  КоллекцияЗначенийБлокировки	- <Структура или Соответствие> - описывает значения блокировки, накладываемые с помощью УстановитьЗначение().
//									Ключ - поле блокировки - <Строка или (только для соответствия) ПланыВидовХарактеристикСсылка>, 
//										ПланыВидовХарактеристикСсылка используется для блокировки регистра бухгалтерии по виду субконто.
//									Значение - блокируемое значение - <Произвольный тип>.
//									Если передано Неопределено или если коллекция не содержит ни одного элемента -
//									блокировки методом УстановитьЗначение() не накладываются.
//  КоллекцияОписанияИсточника	- <Структура или Соответствие> - описывает значения блокировки, накладываемые с помощью ИспользоватьИзИсточникаДанных().
//									Ключ - поле блокировки - <Строка или (только для соответствия) ПланыВидовХарактеристикСсылка>, 
//										ПланыВидовХарактеристикСсылка используется для блокировки регистра бухгалтерии по виду субконто.
//									Значение - поле таблицы источника данных - <Строка>.
//									Если передано Неопределено или если коллекция не содержит ни одного элемента -
//									блокировки методом ИспользоватьИзИсточникаДанных() не накладываются.
//  Отказ 						- <Булево> - при ошибке в процессе установки блокировки в этот параметр процедура возвращает значение Истина
//  Заголовок 					- <Строка> - заголовок сообщения об ошибке при установке блокировки
//
Процедура УстановитьУправляемуюБлокировку(СтруктураПараметров, КоллекцияЗначенийБлокировки = Неопределено, КоллекцияОписанияИсточника = Неопределено, Отказ = Ложь, Заголовок = "") Экспорт
	
	Если НЕ ТипЗнч(СтруктураПараметров) = Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	
	ИспользоватьЗначенияБлокировки = КоллекцияЗначенийБлокировки <> Неопределено 
	И (ТипЗнч(КоллекцияЗначенийБлокировки) = Тип("Структура") 
	ИЛИ ТипЗнч(КоллекцияЗначенийБлокировки) = Тип("Соответствие"))
	И КоллекцияЗначенийБлокировки.Количество() > 0;
	
	ИспользоватьИсточникДанных     = КоллекцияОписанияИсточника <> Неопределено 
	И (ТипЗнч(КоллекцияОписанияИсточника) = Тип("Структура") 
	ИЛИ ТипЗнч(КоллекцияОписанияИсточника) = Тип("Соответствие"))
	И КоллекцияОписанияИсточника.Количество() > 0
	И СтруктураПараметров.Свойство("ИсточникДанных");
	
	Если НЕ ИспользоватьЗначенияБлокировки И НЕ ИспользоватьИсточникДанных Тогда
		Возврат;
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	
	ТипТаблицы = ?(СтруктураПараметров.Свойство("ТипТаблицы"), СтруктураПараметров.ТипТаблицы, "РегистрНакопления");
	ИмяТаблицы = СтруктураПараметров.ИмяТаблицы;
	ПространствоБлокировки = ТипТаблицы  + "." + ИмяТаблицы;
	ЭлементБлокировки = Блокировка.Добавить(ПространствоБлокировки);
	
	РежимБлокировки = ?(СтруктураПараметров.Свойство("РежимБлокировки"), СтруктураПараметров.РежимБлокировки, РежимБлокировкиДанных.Исключительный);
	ЭлементБлокировки.Режим = РежимБлокировки;
	
	Если ИспользоватьЗначенияБлокировки Тогда
		
		Для каждого ЭлементКоллекции Из КоллекцияЗначенийБлокировки Цикл
			
			ЭлементБлокировки.УстановитьЗначение(ЭлементКоллекции.Ключ, ЭлементКоллекции.Значение);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Если ИспользоватьИсточникДанных Тогда
		
		ИсточникДанных = СтруктураПараметров.ИсточникДанных; 
		
		Если ТипЗнч(ИсточникДанных) = Тип("МенеджерВременныхТаблиц") Тогда
			
			Запрос = Новый Запрос;
			Запрос.МенеджерВременныхТаблиц = ИсточникДанных;
			ТекстЗапроса = "";
			Для каждого ЭлементКоллекции Из КоллекцияОписанияИсточника Цикл
				ТекстЗапроса = ТекстЗапроса + ",
				|	Таб." + ЭлементКоллекции.Значение;
			КонецЦикла;
			ТекстЗапроса = Сред(ТекстЗапроса, 2);
			ТекстЗапроса = 			
			"ВЫБРАТЬ РАЗЛИЧНЫЕ"
			+ ТекстЗапроса + "
			|ИЗ
			|	" + СтруктураПараметров.ИмяВременнойТаблицы + " КАК Таб";
			Запрос.Текст = ТекстЗапроса;
			Результат    = Запрос.Выполнить();
			
			ЭлементБлокировки.ИсточникДанных = Результат;
			
		Иначе
			
			ЭлементБлокировки.ИсточникДанных = ИсточникДанных;
			
		КонецЕсли;
		
		Для каждого ЭлементКоллекции Из КоллекцияОписанияИсточника Цикл
			
			ЭлементБлокировки.ИспользоватьИзИсточникаДанных(ЭлементКоллекции.Ключ, ЭлементКоллекции.Значение);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Попытка
		
		Блокировка.Заблокировать();
		
	Исключение
		
		ОбщегоНазначенияДУКлиентСервер.СообщитьОбОшибке(ОписаниеОшибки(), Отказ, Заголовок);
		ТекстОшибки = НСтр("ru = 'Операция не выполнена'");
		ВызватьИсключение ТекстОшибки;
		
	КонецПопытки;
	
КонецПроцедуры

//Удаляет повторяющиеся элементы массива 
// 
// Параметры:
//   Массив - переданный для обработки массив
//   НеИспользоватьНеопределено - флаг неиспользования Неопределено, по умолчанию Ложь
//
// Возвращаемое значение:
//   Массив - массив без повторяющихся элементов
//
Функция УдалитьПовторяющиесяЭлементыМассива(Массив, НеИспользоватьНеопределено = Ложь) Экспорт
	
	ОписаниеТиповСправочники  = Справочники.ТипВсеСсылки(); 
	ОписаниеТиповДокументы    = Документы.ТипВсеСсылки(); 
	ОписаниеТиповПВХ          = ПланыВидовХарактеристик.ТипВсеСсылки(); 
	ОписаниеТиповПланыСчетов  = ПланыСчетов.ТипВсеСсылки(); 
	ОписаниеТиповПланыРасчета = ПланыВидовРасчета.ТипВсеСсылки(); 
	
	Если ТипЗнч(Массив) = Тип("Массив") Тогда 
		
		УжеВМассиве = Новый Соответствие; 
		БылоНеопределено = Ложь;
		
		КолвоЭлементовВМассиве = Массив.Количество(); 
		
		Для ОбратныйИндекс = 1 По КолвоЭлементовВМассиве Цикл 
			ЭлементМассива = Массив[КолвоЭлементовВМассиве - ОбратныйИндекс]; 
			ТипЭлемента = ТипЗнч(ЭлементМассива); 
			Если ЭлементМассива = Неопределено Тогда
				Если БылоНеопределено или НеИспользоватьНеопределено Тогда
					Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
				Иначе
					БылоНеопределено = Истина;
				КонецЕсли;
				Продолжить;
			ИначеЕсли ОписаниеТиповСправочники.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповДокументы.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПВХ.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПланыСчетов.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПланыРасчета.СодержитТип(ТипЭлемента) Тогда 
				
				ИДЭлемента = Строка(ЭлементМассива.УникальныйИдентификатор()); 
				
			Иначе 
				
				ИДЭлемента = ЭлементМассива; 
				
			КонецЕсли; 
			
			Если УжеВМассиве[ИДЭлемента] = Истина Тогда 
				Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
			Иначе 
				УжеВМассиве[ИДЭлемента] = Истина; 
			КонецЕсли; 
		КонецЦикла;      
		
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// СИСТЕМНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

//Функция возвращает Истина, если есть доступ к объекту
//
// Параметры:
//   Объект - проверяемый объект
//
// Возвращаемое значение:
//   Булево
//
Функция ЕстьДоступКОбъекту(Объект) Экспорт
	
	Попытка
		
		УникальныйИдентификатор = Объект.УникальныйИдентификатор();
		
	Исключение
		
		Возврат Истина;
		
	КонецПопытки;
	
	МассивЧастейИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(УникальныйИдентификатор, "-");
	
	ПерваяЧасть		= МассивЧастейИмени[3];
	ВтораяЧасть 	= МассивЧастейИмени[4];
	ТретьяЧасть 	= МассивЧастейИмени[2];
	ЧетвертаяЧасть 	= МассивЧастейИмени[1];
	ПятаяЧасть 		= МассивЧастейИмени[0];
	
	ИдентификаторВИмениОбъекта = ПерваяЧасть + ВтораяЧасть + ТретьяЧасть + ЧетвертаяЧасть + ПятаяЧасть;
	
	СтроковоеПредставлениеОбъекта = Строка(Объект);
	
	Возврат Не Найти(СтроковоеПредставлениеОбъекта, ИдентификаторВИмениОбъекта) > 0;
	
КонецФункции // ЕстьДоступКОбъекту()

// Функция "расщепляет" строку на подстроки, используя заданный 
//		разделитель. Разделитель может иметь любую длину. 
//		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//		игнорируются.
//		Например, 
//		РазложитьСтрокуВМассивПодстрок(",ку,,,му", ",") возвратит массив значений из пяти элементов, 
//		три из которых - пустые строки, а 
//		РазложитьСтрокуВМассивПодстрок(" ку   му", " ") возвратит массив значений из двух элементов
//
//	Параметры: 
//		Стр - 			строка, которую необходимо разложить на подстроки. 
//						Параметр передается по значению.
//		Разделитель - 	строка-разделитель, по умолчанию - запятая.
//
//
//	Возвращаемое значение:
//		массив значений, элементы которого - подстроки
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = СокрЛ(Сред(Стр,Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = Сред(Стр,Поз+ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции

//Функция получает описание типов строки  
//
// Параметры:
//   ДлинаСтроки - заданная длина строки
//
// Возвращаемое значение:
//   описание типов строки с указанной длиной
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт
	Массив = Новый Массив; 
	Массив.Добавить(Тип("Строка"));
	КвалификаторСтроки = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная);
	Возврат Новый ОписаниеТипов(Массив, , КвалификаторСтроки);
КонецФункции


////////////////////////////////////////////////////////////////////////////////

// Процедура удаляет непроверяемые реквииты из массива 
// 
// Параметры:
//   МассивРеквизитов - переданный для обработки массив
//   МассивНепроверяемыхРеквизитов - массив непроверяемых реквизитов
//
// Возвращаемое значение:
//   МассивРеквизитов - массив без непроверяемых реквизитов
//
Процедура УдалитьНепроверяемыеРеквизитыИзМассива(МассивРеквизитов, МассивНепроверяемыхРеквизитов) Экспорт
	
	Для Каждого ЭлементМассива Из МассивНепроверяемыхРеквизитов Цикл
		
		// перед удалением реквизита из массива необходимо проверить, что он там есть
		// (не был удален ранее платформой или в коде).
		ПорядковыйНомер = МассивРеквизитов.Найти(ЭлементМассива);
		Если ПорядковыйНомер <> Неопределено Тогда
			МассивРеквизитов.Удалить(ПорядковыйНомер);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Функция предназначена для определения названия объекта
// учета по его счету учета. Название объекта выдается в родительном падеже
//
// Параметры:
//    СчетУчета - счет учета актива из Плана Счетов
//
// Возвращаемое значение:
//    Название объекта в родительном падеже
//
Функция ПолучитьНазваниеОбъекта(СчетУчета) Экспорт
	
	Если Сред(СчетУчета.Код, 4, 1) = "." Тогда
		СчетУчетаКод = Лев(СчетУчета.Код, 3);
	Иначе
		СчетУчетаКод = Лев(СчетУчета.Код, 2);
	КонецЕсли;
	
	Если СчетУчетаКод = "08" Тогда
		
		Если Лев(СчетУчета.Код, 5) = "08.01" Тогда
			Возврат "земельных участков";
			
		ИначеЕсли Лев(СчетУчета.Код, 5) = "08.02" Тогда
			Возврат "объектов природопользования";
			
		ИначеЕсли Лев(СчетУчета.Код, 5) = "08.03" Тогда
			Возврат "объектов строительства";
			
		ИначеЕсли Лев(СчетУчета.Код, 5) = "08.04" Тогда
			Возврат "оборудования";
			
		ИначеЕсли Лев(СчетУчета.Код, 5) = "08.05" Тогда
			Возврат "нематериальных активов";
			
		ИначеЕсли Лев(СчетУчета.Код, 5) = "08.08" Тогда
			Возврат "НИОКР";
			
		Иначе
			Возврат "внеоборотных активов";
			
		КонецЕсли;
		
	ИначеЕсли СчетУчетаКод = "10" Тогда
		
		Если Лев(СчетУчета.Код, 5) = "10.09" Тогда
			Возврат "инвентаря";
			
		ИначеЕсли Лев(СчетУчета.Код, 7) = "10.11.1" Тогда
			Возврат "спецодежды";
			
		ИначеЕсли Лев(СчетУчета.Код, 7) = "10.11.2" Тогда
			Возврат "спецоснастки";
			
		Иначе
			Возврат "материалов";
			
		КонецЕсли;
		
	ИначеЕсли СчетУчетаКод = "20" Тогда
		Возврат "продукции для давальца";
		
	ИначеЕсли СчетУчетаКод = "21" Тогда
		Возврат "полуфабрикатов";
		
	ИначеЕсли СчетУчетаКод = "41" Тогда
		Возврат "товаров";
		
	ИначеЕсли СчетУчетаКод = "42" Тогда
		Возврат "торговой наценки";
		
	ИначеЕсли СчетУчетаКод = "43" Тогда
		Возврат "продукции";
		
	ИначеЕсли СчетУчетаКод = "45" Тогда
		Возврат "отгруженных товаров";
		
	ИначеЕсли СчетУчетаКод = "001" Тогда
		Возврат "арендованных основных средств";
		
	ИначеЕсли СчетУчетаКод = "002" Тогда
		Возврат "товаров на ответственное хранение";
		
	ИначеЕсли СчетУчетаКод = "003" Тогда
		Возврат "материалов в переработку";
		
	ИначеЕсли СчетУчетаКод = "004" Тогда
		Возврат "товаров комитента";
		
	ИначеЕсли СчетУчетаКод = "005" Тогда
		Возврат "оборудования для монтажа";
		
		// {
	ИначеЕсли СчетУчетаКод = "58" Тогда
		Если Лев(СчетУчета.Код, 5) = "58.01" Тогда
			Возврат "акций";
		ИначеЕсли Лев(СчетУчета.Код, 5) = "58.02" Тогда
			Возврат "облигаций";
		ИначеЕсли Лев(СчетУчета.Код, 5) = "58.03" Тогда
			Возврат "НКД по облигациям";	
		ИначеЕсли Лев(СчетУчета.Код, 5) = "58.04" Тогда
			Возврат "векселей";
		ИначеЕсли Лев(СчетУчета.Код, 5) = "58.05" Тогда
			Возврат "паев";
		ИначеЕсли Лев(СчетУчета.Код, 5) = "58.06" Тогда
			Возврат "ценных бумаг";
		КонецЕсли;
		// }
		
	Иначе
		Возврат "запасов";
		
	КонецЕсли;
	
	
КонецФункции

// Процедура вызывается из форм платежных документов при смене кассы или 
// банковского счета. Меняет валюту, курс документа и пересчитывает сумму.
//
// Параметры:
//  ВалютаДокумента  - ссылка на справочник, валюта документа до изменения;
//  КурсДокумента    - число, курс документа до изменения; 
//  ДатаДокумента    - дата, дата на которую будем получать новый курс; 
//  СуммаДокумента   - число, сумма документа; 
//  ВалютаДенежныхСредств - ссылка на справочник, валюта выбранного счета или кассы 
//                     (новая валюта документа);
//
Процедура ПриИзмененииЗначенияКассыБанковскогоСчета(ВалютаДокумента, КурсДокумента, КратностьДокумента, ДатаДокумента, 
	СуммаДокумента, ВалютаДенежныхСредств) Экспорт
	
	СтараяВалюта    = ВалютаДокумента; 
	СтарыйКурс      = КурсДокумента;
	СтараяКратность = КратностьДокумента;
	ВалютаДокумента = ВалютаДенежныхСредств; 
	
	ВалютаРегл = ОбщегоНазначенияДУ.ВалютаРеглУчета();
	
	СтруктураКурсаВалютаДокумента = МодульВалютногоУчета.ПолучитьКурсВалюты(ВалютаРегл,ВалютаДокумента, ДатаДокумента);
	КурсДокумента        = СтруктураКурсаВалютаДокумента.Курс;
	КратностьДокумента   = СтруктураКурсаВалютаДокумента.Кратность;
	
	Если ВалютаДокумента <>  СтараяВалюта
		И СуммаДокумента > 0 Тогда
		
		СуммаДокумента = МодульВалютногоУчета.ПересчитатьИзВалютыВВалюту(СуммаДокумента, СтараяВалюта, ВалютаДокумента, СтарыйКурс,
		КурсДокумента,СтараяКратность,КратностьДокумента);
		
	КонецЕсли;
	
КонецПроцедуры

// Функция возвращает массив вышестоящих групп указанного элемента.
// 
// Параметры:
//  Элемент      - Элемент справочника, для которого ищется родитель
//
// Возвращаемое значение
//  Массив вышестоящих групп
//
Функция ПолучитьСписокВышеСтоящихГрупп(ЭлементСправочника) Экспорт
	
	Результат = Новый Массив;		
	
	Если НЕ ЗначениеЗаполнено(ЭлементСправочника) Тогда
		Возврат Результат;
	КонецЕсли;
	
	МетаданныеСправочника = ЭлементСправочника.Метаданные();
	Если НЕ МетаданныеСправочника.Иерархический Тогда
		Возврат Результат;
	КонецЕсли;
	ИмяСправочника = МетаданныеСправочника.Имя;	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	Справочник1.Родитель КАК Родитель1,
	|	Справочник2.Родитель КАК Родитель2,
	|	Справочник3.Родитель КАК Родитель3,
	|	Справочник4.Родитель КАК Родитель4,
	|	Справочник5.Родитель КАК Родитель5
	|ИЗ
	|	Справочник." + ИмяСправочника + " КАК Справочник1
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник2
	|		ПО (Справочник2.Ссылка = Справочник1.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник3
	|		ПО (Справочник3.Ссылка = Справочник2.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник4
	|		ПО (Справочник4.Ссылка = Справочник3.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник5
	|		ПО (Справочник5.Ссылка = Справочник4.Родитель)
	|ГДЕ
	|	Справочник1.Ссылка = &Ссылка";
	
	ТекущийЭлемент = ЭлементСправочника;
	
	Пока ЗначениеЗаполнено(ТекущийЭлемент) Цикл		
		Запрос.УстановитьПараметр("Ссылка", ТекущийЭлемент);
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			Для Индекс = 1 по 5 Цикл
				ТекущийЭлемент = Выборка["Родитель" + Индекс];
				Если ЗначениеЗаполнено(ТекущийЭлемент) Тогда
					Результат.Добавить(ТекущийЭлемент);
				Иначе
					Прервать;
				КонецЕсли;				
			КонецЦикла;
		Иначе
			ТекущийЭлемент = Неопределено;
		КонецЕсли;
	КонецЦикла;	
	
	Возврат Результат;
	
КонецФункции

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПОЛУЧЕНИЯ И УСТАНОВКИ НАСТРОЕК ПОЛЬЗОВАТЕЛЕЙ

// Функция возвращает значение по умолчанию для передаваемого пользователя и настройки.
//
// Параметры:
//  Настройка    - Строка - вид настройки, значение по умолчанию которой необходимо получить 
//  Пользователь - СправочникСсылка.Пользователи - пользователь программы, настройка которого 
//				   запрашивается, если параметр не передается настройка возвращается для текущего пользователя
//
// Возвращаемое значение:
//  Значение по умолчанию для настройки.
//
Функция ПолучитьЗначениеПоУмолчанию(Настройка, Пользователь = Неопределено) Экспорт
	
	Если ВРег(Настройка) = ВРег("ОсновнойПортфель") Тогда
		ПустоеЗначение = Справочники.Портфели.ПустаяСсылка();
	ИначеЕсли ВРег(Настройка) = ВРег("ГруппаСозданияЭмитентовПриПодборе") Тогда	
		ПустоеЗначение = Справочники.Контрагенты.ПустаяСсылка();
	Иначе	
		Возврат Неопределено;
	КонецЕсли;
	
	Если Пользователь = Неопределено Тогда
		ЗначениеНастройки = ХранилищеОбщихНастроек.Загрузить(ВРег(Настройка));
	Иначе	
		ЗначениеНастройки = ХранилищеОбщихНастроек.Загрузить(ВРег(Настройка),,, Пользователь);
	КонецЕсли;	
	
	Возврат ?(ЗначениеНастройки = Неопределено, ПустоеЗначение, ЗначениеНастройки);
	
КонецФункции // ПолучитьЗначениеПоУмолчанию()


////////////////////////////////////////////////////////////////////////////////
// СОХРАНЕНИЕ/ВОСТАНОВЛЕНИЕ ПОЛЬЗОВАТЕЛЬСКИХ НАСТРОЕК ОФОРМЛЕНИЯ

//  Функция подготавливает пользовательские настройки  
//
// Параметры:
//   Список - структура значений пользовательских настроек, 
//   Настройки - настройки пользователя
//
// Возвращаемое значение:
//   Настройки  - пользовательские настройки с установленными значениями
//
Функция ПодготовитьПользовательскиеНастройки(Список, Настройки) Экспорт
	
	Настройки.Вставить("Группировка",СериализоватьГруппировки(Список.Группировка));
	Настройки.Вставить("Отбор",СериализоватьОтбор(Список.Отбор));
	Настройки.Вставить("Порядок",СериализоватьПорядок(Список.Порядок));
	Настройки.Вставить("УсловноеОформление",СериализоватьУсловноеОформление(Список.УсловноеОформление));
	
	Возврат Настройки;
	
КонецФункции 

//  Процедура устанавливает пользовательские настройки  
//
// Параметры:
//   Список - структура значений пользовательских настроек, 
//   Настройки - настройки пользователя
//
// Возвращаемое значение:
//   устанавливает пользовательские настройки с установленными значениями
//
Процедура УстановитьПользовательскиеНастройки(Список, Настройки) Экспорт
	
	Группировка = Настройки.Получить("Группировка");
	Если Группировка<>неопределено тогда
		ДесериализоватьГруппировки(Группировка, Список.Группировка);
	КонецЕсли;
	
	Отбор = Настройки.Получить("Отбор");
	Если Отбор<>неопределено тогда
		ДесериализоватьОтбор(Отбор, Список.Отбор);
	КонецЕсли;
	
	Порядок = Настройки.Получить("Порядок");
	Если Порядок<>неопределено тогда
		ДесериализоватьПорядок(Порядок, Список.Порядок);
	КонецЕсли;
	
	УсловноеОформление = Настройки.Получить("УсловноеОформление");
	Если УсловноеОформление<>Неопределено тогда
		ДесериализоватьУсловноеОформление(УсловноеОформление, Список.УсловноеОформление);
	КонецЕсли;
	
КонецПроцедуры


// Группировки
Функция СериализоватьГруппировки(пГруппировки)
	
	// ТипЗнч(пГруппировки) = Тип("ГруппировкаТаблицыКомпоновкиДанных")
	ЗаписьXML = Новый ЗаписьXML();
	ЗаписьXML.УстановитьСтроку();
	ЗаписьXML.ЗаписатьНачалоЭлемента("Группировки");
	Для Каждого _ЭлементГруппировки Из пГруппировки.Элементы Цикл
		СериализаторXDTO.ЗаписатьXML(ЗаписьXML, _ЭлементГруппировки);
	КонецЦикла;
	ЗаписьXML.ЗаписатьКонецЭлемента();
	Возврат ЗаписьXML.Закрыть();
	
КонецФункции // СериализоватьГруппировки()

Процедура ДесериализоватьГруппировки(пНастройки_Группировка, пЗадачи_Группировка)
	
	пЗадачи_Группировка.Элементы.Очистить();
	Если пНастройки_Группировка <> Неопределено Тогда
		ЧтениеXML = Новый ЧтениеXML();
		ЧтениеXML.УстановитьСтроку(пНастройки_Группировка);
		ЧтениеXML.ПерейтиКСодержимому();
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента И ЧтениеXML.Имя = "Группировки" Тогда
			ЧтениеXML.Прочитать();
			Пока ЧтениеXML.ТипУзла <> ТипУзлаXML.КонецЭлемента И ЧтениеXML.Имя <> "Группировки" Цикл
				ПолеГруппировкиXML = СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
				ПолеГруппировки = пЗадачи_Группировка.Элементы.Добавить(Тип("ПолеГруппировкиКомпоновкиДанных"));
				ЗаполнитьЗначенияСвойств(ПолеГруппировки, ПолеГруппировкиXML);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры // ДесериализоватьГруппировки()

// Порядок
Функция СериализоватьПорядок(пПорядок)
	
	ЗаписьXML = Новый ЗаписьXML();
	ЗаписьXML.УстановитьСтроку();
	ЗаписьXML.ЗаписатьНачалоЭлемента("Порядок");
	Для Каждого _ЭлементПорядка Из пПорядок.Элементы Цикл
		СериализаторXDTO.ЗаписатьXML(ЗаписьXML, _ЭлементПорядка);
	КонецЦикла;
	ЗаписьXML.ЗаписатьКонецЭлемента();
	Возврат ЗаписьXML.Закрыть();
	
КонецФункции // СериализоватьПорядок()

Функция ДесериализоватьПорядок(пНастройки_Порядок, пЗадачи_Порядок)
	
	пЗадачи_Порядок.Элементы.Очистить();
	Если пНастройки_Порядок <> Неопределено Тогда
		ЧтениеXML = Новый ЧтениеXML();
		ЧтениеXML.УстановитьСтроку(пНастройки_Порядок);
		ЧтениеXML.ПерейтиКСодержимому();
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента И ЧтениеXML.Имя = "Порядок" Тогда
			ЧтениеXML.Прочитать();
			Пока ЧтениеXML.ТипУзла <> ТипУзлаXML.КонецЭлемента И ЧтениеXML.Имя <> "Порядок" Цикл
				ПолеПорядкаXML = СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
				ПолеПорядка = пЗадачи_Порядок.Элементы.Добавить(ТипЗнч(ПолеПорядкаXML));
				ЗаполнитьЗначенияСвойств(ПолеПорядка, ПолеПорядкаXML);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
КонецФункции // ДесериализоватьПорядок()

// Отборы
Функция СериализоватьОтбор(пОтбор)
	
	ЗаписьXML = Новый ЗаписьXML();
	ЗаписьXML.УстановитьСтроку();
	ЗаписьXML.ЗаписатьНачалоЭлемента("Отборы");
	Для Каждого _ЭлементОтбора Из пОтбор.Элементы Цикл
		СериализаторXDTO.ЗаписатьXML(ЗаписьXML, _ЭлементОтбора);
	КонецЦикла;
	ЗаписьXML.ЗаписатьКонецЭлемента();
	Возврат ЗаписьXML.Закрыть();
	
КонецФункции // СериализоватьОтбор()

Процедура ДесериализоватьОтбор(пНастройки_Отбор, пЗадачи_Отбор)
	
	пЗадачи_Отбор.Элементы.Очистить();
	Если пНастройки_Отбор <> Неопределено Тогда
		ЧтениеXML = Новый ЧтениеXML();
		ЧтениеXML.УстановитьСтроку(пНастройки_Отбор);
		ЧтениеXML.ПерейтиКСодержимому();
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента И ЧтениеXML.Имя = "Отборы" Тогда
			ЧтениеXML.Прочитать();
			Пока ЧтениеXML.ТипУзла <> ТипУзлаXML.КонецЭлемента И ЧтениеXML.Имя <> "Отборы" Цикл
				ПолеОтбораXML = СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
				ПолеОтбора = пЗадачи_Отбор.Элементы.Добавить(ТипЗнч(ПолеОтбораXML));
				СкопироватьЭлементыОтбораРекурсивно(ПолеОтбораXML, ПолеОтбора);
				//ПолеОтбора.Поле = ПолеОтбораXML.Поле;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры // ДесериализоватьОтбор()

Процедура СкопироватьЭлементыОтбораРекурсивно(пОтборОткуда, пОтборКуда);
	
	ЗаполнитьЗначенияСвойств(пОтборКуда, пОтборОткуда);
	Если ТипЗнч(пОтборОткуда) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		Для Каждого ЭлементОтбора Из пОтборОткуда.Элементы Цикл
			НовыйЭлементОтбора = пОтборКуда.Элементы.Добавить(ТипЗнч(ЭлементОтбора));
			СкопироватьЭлементыОтбораРекурсивно(ЭлементОтбора, НовыйЭлементОтбора);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры // СкопироватьЭлементыОтбораРекурсивно()

// Условное оформление
Функция СериализоватьУсловноеОформление(пУсловноеОформление)
	
	ЗаписьXML = Новый ЗаписьXML();
	ЗаписьXML.УстановитьСтроку();
	ЗаписьXML.ЗаписатьНачалоЭлемента("УсловноеОформление");
	Для Каждого _ЭлементУсловногоОформления Из пУсловноеОформление.Элементы Цикл
		СериализаторXDTO.ЗаписатьXML(ЗаписьXML, _ЭлементУсловногоОформления);
	КонецЦикла;
	ЗаписьXML.ЗаписатьКонецЭлемента();
	Возврат ЗаписьXML.Закрыть();
	
КонецФункции // СериализоватьУсловноеОформление()

Функция ДесериализоватьУсловноеОформление(пНастройки_УсловноеОформление, пЗадачи_УсловноеОформление)
	
	пЗадачи_УсловноеОформление.Элементы.Очистить();
	Если пНастройки_УсловноеОформление <> Неопределено Тогда
		ЧтениеXML = Новый ЧтениеXML();
		ЧтениеXML.УстановитьСтроку(пНастройки_УсловноеОформление);
		ЧтениеXML.ПерейтиКСодержимому();
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента И ЧтениеXML.Имя = "УсловноеОформление" Тогда
			ЧтениеXML.Прочитать();
			Пока ЧтениеXML.ТипУзла <> ТипУзлаXML.КонецЭлемента И ЧтениеXML.Имя <> "УсловноеОформление" Цикл
				ПолеУсловногоОформленияXML = СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
				ПолеУсловногоОформления = пЗадачи_УсловноеОформление.Элементы.Добавить();
				ЗаполнитьЗначенияСвойств(ПолеУсловногоОформления, ПолеУсловногоОформленияXML);
				Для Индекс = 0 по ПолеУсловногоОформленияXML.Оформление.ДоступныеПараметры.Элементы.Количество()-1 Цикл
					ЗаполнитьЗначенияСвойств(ПолеУсловногоОформления.Оформление.ДоступныеПараметры.Элементы[Индекс],
					ПолеУсловногоОформленияXML.Оформление.ДоступныеПараметры.Элементы[Индекс]);
				КонецЦикла;
				Для Индекс = 0 по ПолеУсловногоОформленияXML.Оформление.Элементы.Количество()-1 Цикл
					ЗаполнитьЗначенияСвойств(ПолеУсловногоОформления.Оформление.Элементы[Индекс],
					ПолеУсловногоОформленияXML.Оформление.Элементы[Индекс]);
				КонецЦикла;
				Для каждого ЭлементОтбораXML ИЗ ПолеУсловногоОформленияXML.Отбор.Элементы Цикл
					ЭлементОтбора = ПолеУсловногоОформления.Отбор.Элементы.Добавить(ТипЗнч(ЭлементОтбораXML));
					СкопироватьЭлементыОтбораРекурсивно(ЭлементОтбораXML, ЭлементОтбора);
				КонецЦикла;
				Для каждого ПолеXML ИЗ ПолеУсловногоОформленияXML.Поля.Элементы Цикл
					Поле = ПолеУсловногоОформления.Поля.Элементы.Добавить();
					ЗаполнитьЗначенияСвойств(Поле, ПолеXML);
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
КонецФункции // ДесериализоватьПорядок()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ХРАНИЛИЩЕМ ЗНАЧЕНИЙ

Процедура ПеренестиДанныеХранилищаИзТабличнойЧастиФормыВОбъект(ДанныеФормы, ДокументОбъект, ИмяРеквизитаНаКлиенте, ИмяРеквизитаОбъекта, ИмяТабличнойЧасти) Экспорт
	
	Для Каждого СтрокаТЧ ИЗ ДанныеФормы[ИмяТабличнойЧасти] Цикл
		
		Если Не ЭтоАдресВременногоХранилища(СтрокаТЧ[ИмяРеквизитаНаКлиенте]) Тогда
			Продолжить;
		КонецЕсли; 
		
		ИндексСтроки = ДанныеФормы[ИмяТабличнойЧасти].Индекс(СтрокаТЧ);
		
		ДокументОбъект[ИмяТабличнойЧасти][ИндексСтроки][ИмяРеквизитаОбъекта] = Новый ХранилищеЗначения(
		ПолучитьИзВременногоХранилища(СтрокаТЧ[ИмяРеквизитаНаКлиенте]), Новый СжатиеДанных(9));
		
		УдалитьИзВременногоХранилища(СтрокаТЧ[ИмяРеквизитаНаКлиенте]);
		
	КонецЦикла;

КонецПроцедуры

Процедура ПеренестиДанныеХранилищаИзТабличнойЧастиОбъектаВФорму(ДанныеФормы, ДокументОбъект, ИмяРеквизитаНаКлиенте, ИмяРеквизитаОбъекта, ИмяТабличнойЧасти, УникальныйИдентификатор) Экспорт
	
	Для Каждого СтрокаТЧ ИЗ ДокументОбъект[ИмяТабличнойЧасти] Цикл
		
		ПеренестиДанныеХранилищаИзТабличнойЧастиОбъектаВФорму_ПоСтроке(СтрокаТЧ, ДанныеФормы, ДокументОбъект, ИмяРеквизитаНаКлиенте, ИмяРеквизитаОбъекта, ИмяТабличнойЧасти, УникальныйИдентификатор);	
		
	КонецЦикла;

КонецПроцедуры

Процедура ПеренестиДанныеХранилищаИзТабличнойЧастиОбъектаВФорму_ПоСтроке(СтрокаТЧ, ДанныеФормы, ДокументОбъект, ИмяРеквизитаНаКлиенте, ИмяРеквизитаОбъекта, ИмяТабличнойЧасти, УникальныйИдентификатор) Экспорт
	
	ДанныеХранилища = СтрокаТЧ[ИмяРеквизитаОбъекта].Получить();
	
	Если ДанныеХранилища = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	
	ИндексСтроки = ДокументОбъект[ИмяТабличнойЧасти].Индекс(СтрокаТЧ);
	ДанныеФормы[ИмяТабличнойЧасти][ИндексСтроки][ИмяРеквизитаНаКлиенте] = ПоместитьВоВременноеХранилище(ДанныеХранилища, УникальныйИдентификатор);
	
КонецПроцедуры

Процедура ПеренестиДанныеХранилищаИзОбъектаВФорму(РеквизитФормы, ДокументОбъект, ИмяРеквизитаОбъекта, УникальныйИдентификатор) Экспорт
	
	ДанныеХранилища = ДокументОбъект[ИмяРеквизитаОбъекта].Получить();
	
	Если ДанныеХранилища = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	
	РеквизитФормы = ПоместитьВоВременноеХранилище(ДанныеХранилища, УникальныйИдентификатор);
	
КонецПроцедуры

Процедура ПеренестиДанныеХранилищаИзФормыВОбъект(РеквизитФормы, ДокументОбъект, ИмяРеквизитаОбъекта) Экспорт
			
	Если Не ЭтоАдресВременногоХранилища(РеквизитФормы) Тогда
		Возврат;
	КонецЕсли; 
	
	ДокументОбъект[ИмяРеквизитаОбъекта] = Новый ХранилищеЗначения(ПолучитьИзВременногоХранилища(РеквизитФормы), Новый СжатиеДанных(9));
	
	УдалитьИзВременногоХранилища(РеквизитФормы);

КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
// ПРОЧЕЕ

// Процедура создает документ ОтражениеОперацийВРегистрахВУ по документу-основанию  
//
// Параметры:
//   ДокументОснование - исходный документ-основание
//
// Возвращаемое значение:
//   Создаётся новый или перезаполняется имеющийся документ ОтражениеОперацийВРегистрахВУ
//
Процедура ФормированиеДокументаОтражениеОперацийВРегистрахВУ(ДокументОснование) Экспорт
	
	Если ТипЗнч(ДокументОснование) = Тип("ДокументСсылка.ПоступлениеНаРасчетныйСчет") 
		 И (ДокументОснование.ВидОперации = Перечисления.ВидыОперацийПоступлениеДенежныхСредств.ПоступлениеДоходаПоДолевымЦБ
		 ИЛИ ДокументОснование.ВидОперации = Перечисления.ВидыОперацийПоступлениеДенежныхСредств.ПоступлениеДоходаПоОблигацииКупон
		 ИЛИ ДокументОснование.ВидОперации = Перечисления.ВидыОперацийПоступлениеДенежныхСредств.ПоступлениеДоходаПоОблигацииТело) Тогда
		КоррСчет = ДокументОснование.СчетУчетаРасчетовСКонтрагентом;
	ИначеЕсли ТипЗнч(ДокументОснование) = Тип("ДокументСсылка.ОперацияПоСчетуБрокера") 
		 И (ДокументОснование.ВидОперации = Перечисления.ВидыОперацийПоСчетуБрокера.ПоступлениеДоходаПоДолевымЦБ 
		 ИЛИ ДокументОснование.ВидОперации = Перечисления.ВидыОперацийПоСчетуБрокера.ПоступлениеДоходаПоОблигации) Тогда
		КоррСчет = ДокументОснование.КоррСчет;
	Иначе
		Возврат;
	КонецЕсли; 	
	
	Если ЗначениеЗаполнено(ДокументОснование.ДокументОснование) Тогда
		Дата = ДокументОснование.ДокументОснование.Дата;
	Иначе
		Дата = ДокументОснование.Дата;
	КонецЕсли;
	
	Если КоррСчет = ПланыСчетов.Хозрасчетный.РасчетыПоДивидендам Тогда
		
		//Получение цены дивидендов на одну акцию и количества акций
		АктивОбъект =  ДокументОснование.ДолеваяЦБ;
		
		ДокументНачислениеДивидендов = ДокументОснование.ДокументОснование;
		
		Если ЗначениеЗаполнено(ДокументНачислениеДивидендов) И ЗначениеЗаполнено(АктивОбъект) И ДокументНачислениеДивидендов.ДолеваяЦБ = АктивОбъект  Тогда
			Если ТипЗнч(ДокументНачислениеДивидендов) = Тип("ДокументСсылка.ПуловоеНачислениеДивидендов") Тогда
				Цена =  ДокументНачислениеДивидендов.СуммаДивидендовНаОднуЦБ;
			ИначеЕсли ТипЗнч(ДокументНачислениеДивидендов) = Тип("ДокументСсылка.НачислениеДоходаПоДолевымЦБ") Тогда
				Цена =  ДокументНачислениеДивидендов.СуммаДивидендовНаОднуЦБ;
			Иначе	
				Возврат;
			КонецЕсли;
		Иначе
			Возврат;
		КонецЕсли;
		
		Количество = ПолучитьКоличество(Дата, АктивОбъект, ДокументОснование.Портфель);
		
	ИначеЕсли КоррСчет = ПланыСчетов.Хозрасчетный.РасчетыПоОблигациям_ПогашениеТела Тогда
		
		//Расчет цены и количества облигаций
		АктивОбъект =  ДокументОснование.Облигация;
		
		Если ЗначениеЗаполнено(АктивОбъект) Тогда
			
			Цена = Справочники.Облигации.ПолучитьНоминальнуюСтоимость(АктивОбъект, Дата);
			ВалютаРегл = ОбщегоНазначенияДУ.ВалютаРеглУчета(ДокументОснование.Портфель);
			ВалютаНоминальнойСтоимости = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(АктивОбъект, "ВалютаНоминала");
			Если Не ВалютаНоминальнойСтоимости = ДокументОснование.ВалютаДокумента тогда
				КурсыВалютПоДате = МодульВалютногоУчета.КурсыВалютПоДатеПоПортфелю(ДокументОснование.Портфель, Дата);
				КурсКратностьВалютыНоминальнойСтоимости = КурсыВалютПоДате.Получить(ВалютаНоминальнойСтоимости);
				КурсКратностьВалютыДокумента = КурсыВалютПоДате.Получить(ДокументОснование.ВалютаДокумента);
				
				Цена = МодульВалютногоУчета.ПересчитатьИзВалютыВВалюту(Цена, 
				ВалютаНоминальнойСтоимости, ДокументОснование.ВалютаДокумента, 
				КурсКратностьВалютыНоминальнойСтоимости.Курс, КурсКратностьВалютыДокумента.Курс,
				КурсКратностьВалютыНоминальнойСтоимости.Кратность, КурсКратностьВалютыДокумента.Кратность);
			КонецЕсли;
			
		Иначе	
			Возврат;
		КонецЕсли; 
		
		Количество = ПолучитьКоличество(Дата, АктивОбъект, ДокументОснование.Портфель);
		
	ИначеЕсли КоррСчет = ПланыСчетов.Хозрасчетный.РасчетыПоОблигациям Тогда
		
		//Расчет цены купона и количества облигаций
		АктивОбъект =  ДокументОснование.Облигация;
		Купон =      ДокументОснование.КупонныйПериод;
		
		Если ЗначениеЗаполнено(АктивОбъект) Тогда
			
			Цена = Перечисления.МетодыРасчетаНКД.НКД_НаДату(АктивОбъект, Купон, Дата);
			ВалютаРегл = ОбщегоНазначенияДУ.ВалютаРеглУчета(ДокументОснование.Портфель);
			ВалютаНоминальнойСтоимости = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(АктивОбъект, "ВалютаНоминала");
			Если Не ВалютаНоминальнойСтоимости = ДокументОснование.ВалютаДокумента тогда
				КурсыВалютПоДате = МодульВалютногоУчета.КурсыВалютПоДатеПоПортфелю(ДокументОснование.Портфель, Дата);
				КурсКратностьВалютыНоминальнойСтоимости = КурсыВалютПоДате.Получить(ВалютаНоминальнойСтоимости);
				КурсКратностьВалютыДокумента = КурсыВалютПоДате.Получить(ДокументОснование.ВалютаДокумента);
				
				Цена = МодульВалютногоУчета.ПересчитатьИзВалютыВВалюту(Цена, 
				ВалютаНоминальнойСтоимости, ДокументОснование.ВалютаДокумента, 
				КурсКратностьВалютыНоминальнойСтоимости.Курс, КурсКратностьВалютыДокумента.Курс,
				КурсКратностьВалютыНоминальнойСтоимости.Кратность, КурсКратностьВалютыДокумента.Кратность);
				
			КонецЕсли;
			
		Иначе	
			Возврат;
		КонецЕсли;
		
		Количество = ПолучитьКоличество(Дата, АктивОбъект, ДокументОснование.Портфель);
		
	Иначе
		Возврат;
	КонецЕсли;	
	
	
	//Создаем новый документ
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ОтражениеОперацийВРегистрахВУ.Ссылка
		|ИЗ
		|	Документ.ОтражениеОперацийВРегистрахВУ КАК ОтражениеОперацийВРегистрахВУ
		|ГДЕ
		|	ОтражениеОперацийВРегистрахВУ.ДокументОснование = &ДокументОснование";
	
	Запрос.УстановитьПараметр("ДокументОснование", ДокументОснование);
	
	Результат = Запрос.Выполнить();
	
	ВыборкаДетальныеЗаписи = Результат.Выбрать();
	
	Если ВыборкаДетальныеЗаписи.Следующий() Тогда
		УчетныйДокумент = ВыборкаДетальныеЗаписи.Ссылка.ПолучитьОбъект();
	Иначе
		УчетныйДокумент = Документы.ОтражениеОперацийВРегистрахВУ.СоздатьДокумент();
		УчетныйДокумент.Дата = ДокументОснование.Дата;
	КонецЕсли;
	
	УчетныйДокумент.Портфель = ДокументОснование.Портфель;
	УчетныйДокумент.ЦБ = АктивОбъект;
	УчетныйДокумент.Цена = Цена;
	УчетныйДокумент.Количество = Количество;
	УчетныйДокумент.Сумма = ДокументОснование.СуммаДокумента;
	УчетныйДокумент.КоррСчет = КоррСчет;
	УчетныйДокумент.ДокументОснование = ДокументОснование;
	УчетныйДокумент.Записать();
	
КонецПроцедуры

// Функция получает количество ценных бумаг
//
// Параметры: 
//  Дата - дата получения количества
//  Актив - Тип Акции или Облигации
//  Портфель - договор ДУ, по которому определяем количество
//
// Возвращаемое значение:
//  Количество
//
Функция ПолучитьКоличество(Дата, Актив, Портфель)

	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ХозрасчетныйОстатки.Счет,
		|	ХозрасчетныйОстатки.КоличествоОстаток
		|ИЗ
		|	РегистрБухгалтерии.Хозрасчетный.Остатки(
		|			КОНЕЦПЕРИОДА(&Дата, ДЕНЬ),
		|			Счет = ЗНАЧЕНИЕ(ПланСчетов.Хозрасчетный.ОблигацииТело),
		|			,
		|			Портфель = &Портфель
		|				И Субконто1 = &Актив) КАК ХозрасчетныйОстатки";
		
	Если ТипЗнч(Актив) = Тип("СправочникСсылка.Акции") Тогда
	
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "ОблигацииТело", "АкцииТело"); 	
	
	КонецЕсли; 

	Запрос.УстановитьПараметр("Актив", Актив);
	Запрос.УстановитьПараметр("Дата", Дата);
	Запрос.УстановитьПараметр("Портфель", Портфель);

	Результат = Запрос.Выполнить();

	ВыборкаДетальныеЗаписи = Результат.Выбрать();

	Если ВыборкаДетальныеЗаписи.Следующий() Тогда
		Возврат ВыборкаДетальныеЗаписи.КоличествоОстаток;
	Иначе
		Возврат Число(0);
	КонецЕсли;
	
КонецФункции

// Функция получает алгоритм расчета
//
// Входные параметры:
//  Объект - объект, для которого необходимо получить  алгоритм расчета
//  Дата - дата, на которую необходимо получить алгоритм расчета
//
// Возвращаемое значение:
//  АлгоритмРасчета - ссылка на полученный алгоритм расчета
//
Функция ПолучитьАлгоритмРасчета(Объект, Дата) Экспорт
	
	ПараметрыАлгоритма = Новый Структура;
	
	ТабАлгоритма = РегистрыСведений.ПараметрыРасчетаБанковскихПроцентов.СрезПоследних(Дата, Новый Структура("БанковскийСчет", Объект));
	Если ТабАлгоритма.Количество() > 0 Тогда
		ПараметрыАлгоритма.Вставить("Алгоритм"	, ТабАлгоритма[0].Алгоритм);
		ПараметрыАлгоритма.Вставить("Контрагент", ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Объект, "Контрагент"));
		ПараметрыАлгоритма.Вставить("Договор"	, ТабАлгоритма[0].Договор);
	Иначе
		ПараметрыАлгоритма.Вставить("Алгоритм"	, Справочники.ДополнительныеОтчетыИОбработки.ПустаяСсылка());
		ПараметрыАлгоритма.Вставить("Контрагент", Справочники.Контрагенты.ПустаяСсылка());
		ПараметрыАлгоритма.Вставить("Договор"	, Справочники.ДоговорыКонтрагентов.ПустаяСсылка());
	КонецЕсли;
	
	Возврат ПараметрыАлгоритма;
КонецФункции // ПолучитьАлгоритмРасчета()

// Форматирует сумму прописью банковского платежного документа
//
// Параметры:
//  Сумма - число - реквизит, который надо представить прописью 
//  Валюта - СправочникСсылка.Валюты - валюта, в которой нужно представить сумму
//  ВыводитьСуммуБезКопеек - булево - флаг представления суммы без копеек
//
// Возвращаемое значение
//  Отформатированная строка
//
Функция ФорматироватьСуммуПрописьюПлатежногоДокумента(Сумма, Валюта, ВыводитьСуммуБезКопеек = Ложь) Экспорт
	
	Результат     = Сумма;
	ЦелаяЧасть    = Цел(Сумма);
	ФорматСтрока  = "Л=ru_RU; ДП=Ложь";
	ПарамПредмета = Валюта.ПараметрыПрописиНаРусском;
	
	Если Результат = ЦелаяЧасть Тогда
		Если ВыводитьСуммуБезКопеек Тогда
			Результат = ЧислоПрописью(Результат, ФорматСтрока, ПарамПредмета);
			Результат = Лев(Результат, Найти(Результат, "0") - 1);
		Иначе
			Результат = ЧислоПрописью(Результат, ФорматСтрока, ПарамПредмета);
		КонецЕсли;
	Иначе
		Результат = ЧислоПрописью(Результат, ФорматСтрока, ПарамПредмета);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ФорматироватьСуммуПрописьюПлатежногоДокумента()

// Функция получает доступные периоды отчета
//
// Параметры:   нет
//
// Возвращаемое значение:
//  ДоступныеПериодыОтчета - структура с доступными периодами
//
Функция ПолучитьДоступныеПериодыОтчета() Экспорт
	
	ДоступныеПериодыОтчета = Новый Структура;
	Для Каждого ЗначениеПеречисления Из Метаданные.Перечисления.ДоступныеПериодыОтчета.ЗначенияПеречисления Цикл
		ДоступныеПериодыОтчета.Вставить(
		ЗначениеПеречисления.Имя, Перечисления.ДоступныеПериодыОтчета[ЗначениеПеречисления.Имя]);
	КонецЦикла;
	
	Возврат ДоступныеПериодыОтчета;
	
КонецФункции

// Проверяет, умещаются ли переданные табличные документы на страницу при печати.
//
// Параметры
//  ТабДокумент       – Табличный документ
//  ВыводимыеОбласти  – Массив из проверяемых таблиц или табличный документ
//  РезультатПриОшибке - Какой возвращать результат при возникновении ошибки
//
// Возвращаемое значение:
//   Булево   – умещаются или нет переданные документы
//
Функция ПроверитьВыводТабличногоДокумента(ТабДокумент, ВыводимыеОбласти, РезультатПриОшибке = Истина) Экспорт
	
	Попытка
		Возврат ТабДокумент.ПроверитьВывод(ВыводимыеОбласти);
	Исключение
		Возврат РезультатПриОшибке;
	КонецПопытки;
	
КонецФункции // ПроверитьВыводТабличногоДокумента()

// Функция добавляет к дате количество периодов  
//
// Параметры: 
//  ВходящаяДата - дата начала периода
//  ТипДаты - тип даты, определяет выбор периода в запросе, например, ДЕНЬ и т.п.
//  Количество - количество прибавляемых периодов
//
// Возвращаемое значение:
//  ЗначениеВозврата - полученая дата
//
Функция ДобавитьКДате(ВходящаяДата, ТипДаты, Количество) Экспорт
	ШаблонЗапроса = 
	"ВЫБРАТЬ
	|	ДОБАВИТЬКДАТЕ(&ВходящаяДата, ТипДаты, &Количество) КАК ИсходящаяДата";
	ШаблонЗапроса = СтрЗаменить(ШаблонЗапроса, "ТипДаты", ТипДаты);
	ЗначениеВозврата = ВходящаяДата;
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ВходящаяДата", ВходящаяДата);
	Запрос.УстановитьПараметр("Количество", Количество);
	Запрос.Текст = ШаблонЗапроса;
	Результат = Запрос.Выполнить().Выбрать();
	Если Результат.Следующий() Тогда
		ЗначениеВозврата = Результат.ИсходящаяДата;
	КонецЕсли;
	Возврат ЗначениеВозврата;
	
КонецФункции

// Функция получает количество периодов  
//
// Параметры: 
//  НачалоПериода - дата начала периода
//  ОкончаниеПериода - дата окончания периода
//  ТипДаты - тип даты, определяет выбор периода в запросе, например, ДЕНЬ и т.п.
//
// Возвращаемое значение:
//  ЗначениеВозврата - количество периодов
//
Функция КоличествоПериодов(НачалоПериода, ОкончаниеПериода, ТипДаты) Экспорт
	
	ЗначениеВозврата = 0;
	Если НачалоПериода>=ОкончаниеПериода Тогда
		Возврат ЗначениеВозврата;
	КонецЕсли;
	ШаблонЗапроса = 
	"ВЫБРАТЬ
	|	РАЗНОСТЬДАТ(&НачалоПериода, &ОкончаниеПериода, ТипДаты) КАК КоличествоПериодов";
	ШаблонЗапроса = СтрЗаменить(ШаблонЗапроса, "ТипДаты", ТипДаты);
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("НачалоПериода", НачалоПериода);
	Запрос.УстановитьПараметр("ОкончаниеПериода", ОкончаниеПериода);
	Запрос.Текст = ШаблонЗапроса;
	Результат = Запрос.Выполнить().Выбрать();
	Если Результат.Следующий() Тогда
		ЗначениеВозврата = Результат.КоличествоПериодов+1;
	КонецЕсли;
	
	Возврат ЗначениеВозврата;
	
КонецФункции

// Функция возвращает структуру реквизитов документа 
//
// Параметры:
// НаименованиеДокумента - строка
//
// Возвращаемое значение:
//  Структура - структура реквизитов
//
Функция ПолучитьСтруктуруРеквизитовДокумента(НаименованиеДокумента) Экспорт

	СтруктураРеквизитов = Новый Структура;
	
	ОбъектМетаданных = Метаданные.Документы[НаименованиеДокумента];
	Для Каждого ТекРеквизит Из ОбъектМетаданных.Реквизиты Цикл
		СтруктураРеквизитов.Вставить(ТекРеквизит.Имя);
	КонецЦикла;	

	Для Каждого ОбщийРеквизит Из Метаданные.ОбщиеРеквизиты Цикл 
		Состав = ОбщийРеквизит.Состав.Найти(ОбъектМетаданных); 
		Если Состав = Неопределено Тогда 
			Продолжить;
		КонецЕсли; 
		Если Состав.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.Использовать 
			Или (Состав.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.Авто И ОбщийРеквизит.АвтоИспользование = Метаданные.СвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать) Тогда 
			СтруктураРеквизитов.Вставить(ОбщийРеквизит.Имя);
		КонецЕсли; 
	КонецЦикла; 

	Возврат СтруктураРеквизитов;

КонецФункции // ()

// Функция возвращает структуру реквизитов справочника 
//
// Параметры:
// НаименованиеСправочника - Строка
//
// Возвращаемое значение:
//  Структура - структура реквизитов
//
Функция ПолучитьСтруктуруРеквизитовСправочника(НаименованиеСправочника) Экспорт

	СтруктураРеквизитов = Новый Структура;
	
	Для каждого ТекРеквизит Из Метаданные.Справочники[НаименованиеСправочника].Реквизиты Цикл
		СтруктураРеквизитов.Вставить(ТекРеквизит.Имя);
	КонецЦикла;	

	Возврат СтруктураРеквизитов;
	
КонецФункции // ()

Функция ФорматРазностиПериодов(ДатаНач, ДатаКон, ВМиллисекундах = Ложь) Экспорт
	
	КолСекунд = ДатаКон - ДатаНач;
	Если ВМиллисекундах Тогда
		КолСекунд = КолСекунд / 1000;		
	КонецЕсли; 
	
	чч = ЦЕЛ(КолСекунд/3600);
	мм = ЦЕЛ((КолСекунд - чч*3600)/60);
	сс = КолСекунд - чч*3600 - мм*60;
	
	СтрокаВремя = Формат(чч, "ЧЦ=2; ЧН=00; ЧВН=") + ":" +
	 Формат(мм, "ЧЦ=2; ЧН=00; ЧВН=") + ":" +
	 Формат(сс, "ЧЦ=2; ЧН=00; ЧВН=") +
	 " ("+КолСекунд+" сек.)";
	 
	Возврат СтрокаВремя;	 
	 	
КонецФункции

Функция ИмяЗначенияПеречисления(ЗначениеПеречисления) Экспорт
		
	ИмяПеречисления = ЗначениеПеречисления.Метаданные().Имя;
	
	ИндексЗначенияПеречисления = Перечисления[ИмяПеречисления].Индекс(ЗначениеПеречисления);
	
	Возврат Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления[ИндексЗначенияПеречисления].Имя;
		
КонецФункции

// Функция создает из коллекции структуру 
//
// Параметры:
//  Коллекция		 - ТаблицаЗначений,ДанныеФормыКоллекция	 - коллекция
//  ИмяПоляКлюча	 - Строка	 - имя поля для ключа структуры
//  ИмяПоляЗначения	 - Строка	 - имя поля для значения структуры
// 
// Возвращаемое значение:
//  Структура - 
//
Функция СтруктураИзКоллекции(Коллекция, ИмяПоляКлюча, ИмяПоляЗначения) Экспорт
	Структура = Новый Структура;
	Для Каждого Элемент Из Коллекция Цикл
		Структура.Вставить(Элемент[ИмяПоляКлюча], Элемент[ИмяПоляЗначения]);
	КонецЦикла;  	
	Возврат Структура;
КонецФункции

// Процедура проверяет переданный параметр, если он не соответствует значению, 
// то присваивает ему указанное значение.
//
// Параметры:
//  Параметр - параметр, значение которого проверяется и заполняется.
//  Значение - значение для заполнения пустого параметра.
//
Процедура УстановитьНовоеЗначение(Параметр, Значение) Экспорт 
	
	Если Параметр <> Значение Тогда
		Параметр = Значение;
	КонецЕсли;
	
КонецПроцедуры

//Функция добавляет "ЧислоДней" к "Дата"
//
Функция ДобавитьДень(Дата, ЧислоДней) Экспорт
	
	Возврат Дата + ЧислоДней * 86400; // 86400 = 24*60*60 - число секунд в дне;
	
КонецФункции

Функция НачалоНеделиПоМесяцу(ДатаНачала) Экспорт
	
	Если День(ДатаНачала) < 7 Тогда
		Возврат ?(День(НачалоНедели(ДатаНачала))>День(ДатаНачала),НачалоМесяца(ДатаНачала),НачалоНедели(ДатаНачала));
	Иначе
		Возврат НачалоНедели(ДатаНачала);
	КонецЕсли;
	
КонецФункции // НачалоНеделиПоМесяцу

// Функция добавляет интервал к дате
//
// Параметры:
//	Периодичность (Перечисления.Периодичность)	- пнриодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//	Смещение (число)							- определяет направление и количество периодов, в котором сдвигается дата
//
// Возвращаемое значение:
//	Дата, отстоящая от исходной на заданное количество периодов 
//
Функция ДобавитьИнтервал(ДатаПериода,Периодичность,Смещение) Экспорт
	
	Если Смещение = 0 Тогда
		НоваяДатаПериода = ДатаПериода;
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.День Тогда
		НоваяДатаПериода = НачалоДня(ДатаПериода + Смещение*24*3600);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Неделя Тогда
		НоваяДатаПериода = НачалоНеделиПоМесяцу(ДатаПериода + Смещение*7*24*3600);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Декада Тогда
		НоваяДатаПериода = НачалоДекады(ДатаПериода + Смещение*11*24*3600);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*3);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Год Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*12);
		
	Иначе
		НоваяДатаПериода=НачалоДня(ДатаПериода) + Смещение*24*3600;
		
	КонецЕсли;
	
	Возврат НоваяДатаПериода;
	
КонецФункции // ДобавитьИнтервал()

Функция НачалоДекады(ДатаНачала) Экспорт
	
	Если День(ДатаНачала) < 10 Тогда
		Возврат НачалоМесяца(ДатаНачала);
	ИначеЕсли День(ДатаНачала) < 20 Тогда
		Возврат ОбщегоНазначенияДУ.ДобавитьДень(НачалоМесяца(ДатаНачала), 10);
	Иначе 
		Возврат ОбщегоНазначенияДУ.ДобавитьДень(НачалоМесяца(ДатаНачала), 20);
	КонецЕсли;
	
КонецФункции // НачалоДекады()

// Функция формирует представление адреса из отдельных элементов
//
// Параметры:
//    СтруктураАдреса - структура с элементами адреса:
//    Страна, Индекс, Регион, Область, НаселенныйПункт, Улица, Дом, Строение, Корпус, Квартира
//
// Возвращаемое значение:
//    Строка - представление контактной информации.
//
Функция ПредставлениеАдреса(СтруктураАдреса) Экспорт
	
	Результат = "";
		
	Если СтруктураАдреса.Свойство("Страна") и СтруктураАдреса.Страна = Справочники.СтраныМира.Россия Тогда
		
		ВидИнформации = Новый Структура;
		ВидИнформации.Вставить("Тип", Перечисления.ТипыКонтактнойИнформации.Адрес);
		ВидИнформации.Вставить("ФорматАдреса", "КЛАДР"); 
		ВидИнформации.Вставить("ВключатьСтрануВПредставление", Ложь); 
		
		Результат = УправлениеКонтактнойИнформациейСлужебный.СформироватьПредставлениеКонтактнойИнформации(СтруктураАдреса, ВидИнформации); 
		
	Иначе
		
		Для каждого Элемент Из СтруктураАдреса Цикл
			Если ЗначениеЗаполнено(Элемент.Значение) Тогда
				Результат = Результат + Строка(Элемент.Значение) + ", ";
			КонецЕсли;
		КонецЦикла;
		
		Если Результат <> "" Тогда
			Результат = Лев(Результат, СтрДлина(Результат) -2);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Функция возвращает массив документов удовлетворяющих отбору
//
// Параметры:
//    ИмяДокумента - Строка
//    СтруктураОтбора - Структура, содержащая в ключе имя реквизита
//    ДатаС - Дата с которой будет произведена выборка
//    ДатаПо - Дата по которую будет произведена выборка
// Возвращаемое значение:
//    Массив ссылок на документы.
//
Функция ДокументыПоОтбору(ИмяДокумента, СтруктураОтбора, ДатаС= '00010101', ДатаПо = '00010101') Экспорт 
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ВидДокументаЗапроса.Ссылка КАК Ссылка
	|ИЗ
	|	Документ.СписаниеСРасчетногоСчета КАК ВидДокументаЗапроса
	|ГДЕ
	|	1 = 1";
	
	СтрокаУсловий = "";
	Для Каждого СтрокаОтбора Из СтруктураОтбора Цикл
		СтрокаУсловий = СтрокаУсловий + СтрШаблон("	И ВидДокументаЗапроса.%1 = &%2", СтрокаОтбора.Ключ, СтрокаОтбора.Ключ);	
		Запрос.УстановитьПараметр(СтрокаОтбора.Ключ, СтрокаОтбора.Значение);
	КонецЦикла;
	
	Если ЗначениеЗаполнено(ДатаС) И ЗначениеЗаполнено(ДатаПо) Тогда 
		СтрокаУсловий = СтрокаУсловий + "	И ВидДокументаЗапроса.Дата Между &ДатаС И &ДатаПо";	
		Запрос.УстановитьПараметр("ДатаС", ДатаС);	
		Запрос.УстановитьПараметр("ДатаПо", ДатаПо);
	ИначеЕсли ЗначениеЗаполнено(ДатаС) Тогда 
		СтрокаУсловий = СтрокаУсловий + "	И ВидДокументаЗапроса.Дата >= &ДатаС";	
		Запрос.УстановитьПараметр("ДатаС", ДатаС);	
	ИначеЕсли ЗначениеЗаполнено(ДатаПо) Тогда 
		СтрокаУсловий = СтрокаУсловий + "	И ВидДокументаЗапроса.Дата <= &ДатаПо";	
		Запрос.УстановитьПараметр("ДатаПо", ДатаПо);	
	КонецЕсли;
	
	Запрос.Текст = Запрос.Текст + СтрокаУсловий;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "СписаниеСРасчетногоСчета", ИмяДокумента); 
	
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции

#Область РАБОТА_С_КОЛЛЕКЦИЯМИ

// Добавляет в таблицу значений строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
//
Процедура ЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник) Экспорт
	
	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл
		
		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);
		
	КонецЦикла;
	
КонецПроцедуры // ЗагрузитьВТаблицуЗначений()

// Процедура упорядовачивает таблицу по документу  
//
// Параметры:
//   ТаблицаЗначений - исходная таблица значений, 
//   КолонкаДокумента - колонка с документами, по которой будет производится упорядочивание, 
//   КолонкаДаты - колонка с датой документа, 
//   Направление - направление упорядочивания, по умолчанию "Возр"
//
Процедура УпорядочитьТаблицуПоДокументу(ТаблицаЗначений, КолонкаДокумента, КолонкаДаты, Направление = "Возр") Экспорт
	
	КолонкаВнешнегоНомера = "ВнешнийНомерСделкиДляСортировки";
	КолонкаНомера = "НомерСделкиДляСортировки";
		
	Если ТаблицаЗначений.Колонки.Найти(КолонкаДаты) = Неопределено Тогда
		ТаблицаЗначений.Колонки.Добавить(КолонкаДаты, ОбщегоНазначенияДУКлиентСервер.ПолучитьОписаниеТиповДаты(ЧастиДаты.ДатаВремя));
	КонецЕсли;
	
	Если ТаблицаЗначений.Колонки.Найти(КолонкаВнешнегоНомера) = Неопределено Тогда
		ТаблицаЗначений.Колонки.Добавить(КолонкаВнешнегоНомера, ОбщегоНазначенияДУКлиентСервер.ПолучитьОписаниеТиповСтроки(500));
	КонецЕсли;

	Если ТаблицаЗначений.Колонки.Найти(КолонкаНомера) = Неопределено Тогда
		ТаблицаЗначений.Колонки.Добавить(КолонкаНомера, ОбщегоНазначенияДУКлиентСервер.ПолучитьОписаниеТиповСтроки(500));
	КонецЕсли;

	Если ТаблицаЗначений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	КэшПоТипам = Новый Соответствие;
	
	Для Каждого СтрокаТаблицы Из ТаблицаЗначений Цикл
		
		Если НЕ ЗначениеЗаполнено(СтрокаТаблицы[КолонкаДокумента]) Тогда 
			Продолжить;
		КонецЕсли;
		
		ТипТекущегоДокумента = ТипЗнч(СтрокаТаблицы[КолонкаДокумента]);
		Если Документы.ТипВсеСсылки().СодержитТип(ТипТекущегоДокумента)
			Или БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипТекущегоДокумента) Тогда
			МассивТипа = КэшПоТипам[ТипТекущегоДокумента];
			Если МассивТипа = Неопределено Тогда
				МассивТипа = Новый Массив;
				КэшПоТипам.Вставить(ТипТекущегоДокумента, МассивТипа);
			КонецЕсли;
			МассивТипа.Добавить(СтрокаТаблицы[КолонкаДокумента]);
		КонецЕсли;
		
	КонецЦикла;
	
	Если КэшПоТипам.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ТаблицаЗначений.Индексы.Добавить(КолонкаДокумента);
	
	Запрос = Новый Запрос;
	
	Для Каждого КлючИЗначение Из КэшПоТипам Цикл
		
		Если Документы.ТипВсеСсылки().СодержитТип(КлючИЗначение.Ключ) Тогда
			ИмяКласса = "Документ";
		Иначе
			ИмяКласса = "БизнесПроцесс";
		КонецЕсли;
		
		МетаданныеДокумента = Метаданные.НайтиПоТипу(КлючИЗначение.Ключ);
		Если ОбщегоНазначения.ЕстьРеквизитОбъекта("НомерВходящегоДокумента", МетаданныеДокумента) Тогда 
			ТекстПоляНомераВх = "Док.НомерВходящегоДокумента";
		ИначеЕсли ОбщегоНазначения.ЕстьРеквизитОбъекта("НомерСделки", МетаданныеДокумента) Тогда 
			ТекстПоляНомераВх = "Док.НомерСделки";
		Иначе
			ТекстПоляНомераВх = """""";
		КонецЕсли;
		
		ИмяМетаданных = МетаданныеДокумента.Имя;
		
		Запрос.Текст = Запрос.Текст
			+ ?(Запрос.Текст = "", "",
			" 
			|ОБЪЕДИНИТЬ ВСЕ
			|")
			+ "
			|ВЫБРАТЬ
			|	Док.Ссылка Как Ссылка,
			|	" + ТекстПоляНомераВх + " Как " + КолонкаВнешнегоНомера + ",
			|	Док.Номер Как " + КолонкаНомера + ",
			|	Док.Дата
			|ИЗ "     
			+ ИмяКласса + "." + ИмяМетаданных + " КАК Док
			|ГДЕ Док.Ссылка В (&ДокументыТипа_" + ИмяМетаданных + ")";
		Запрос.УстановитьПараметр("ДокументыТипа_" + ИмяМетаданных, КлючИЗначение.Значение);
		
	КонецЦикла;
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		СтрокиДокумента = ТаблицаЗначений.НайтиСтроки(Новый Структура(КолонкаДокумента, Выборка.Ссылка));
		Для Каждого СтрокаДокумента Из СтрокиДокумента Цикл
			СтрокаДокумента[КолонкаДаты] = Выборка.Дата;
			СтрокаДокумента[КолонкаВнешнегоНомера] = Выборка[КолонкаВнешнегоНомера];
			СтрокаДокумента[КолонкаНомера] = Выборка[КолонкаНомера];
			
			ОбщегоНазначенияДУПереопределяемый.УпорядочитьТаблицуПоДокументуПриДобавленииСтроки(СтрокаДокумента);
		КонецЦикла;
	КонецЦикла;
	
	СписокКолонок = КолонкаДаты + " " + Направление + ", " + КолонкаВнешнегоНомера + " " + Направление + ", " + КолонкаНомера + " " + Направление + ", " + КолонкаДокумента + " " + Направление;
	
	ТаблицаЗначений.Сортировать(СписокКолонок, Новый СравнениеЗначений);
	
КонецПроцедуры

// Процедура пронумеровывает таблицу   
//
// Параметры:
//   ТаблицаЗначений - исходная таблица значений, 
//   ИмяКолонкиНомера - колонка с номером, по умолчанию "НомерСтроки", 
//
Процедура ПронумероватьТаблицу(ТаблицаЗначений, ИмяКолонкиНомера = "НомерСтроки") Экспорт
	
	Если ТаблицаЗначений.Колонки.Найти(ИмяКолонкиНомера) = Неопределено Тогда
		ТаблицаЗначений.Колонки.Добавить(ИмяКолонкиНомера, Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(10, 0)));
	КонецЕсли;
	
	Ном = 1;
	Для каждого СтрокаТаблицы Из ТаблицаЗначений Цикл
		СтрокаТаблицы[ИмяКолонкиНомера] = Ном;
		Ном = Ном + 1;
	КонецЦикла;
	
КонецПроцедуры

// Свертка таблицы с авто-определением колонок измерений \ ресурсов
//
//Параметры:
// Таблица - ТаблицаЗначений - Колонки должны быть типизированы
// ПоРесурсам - Булево - если установить в ЛОЖЬ, то свертка произойдет по всем колонкам
// ИменаКолонокРесурсовИсключений - Строка - при автоопределении все колонки, содержащие тип "Число" считаются ресурсными. Если какие-то из
//									них должны быть измерениями, в этот параметр передается список их имен, через запятую.
//
Процедура СвернутьТаблицуЗначений(Таблица, ПоРесурсам = Истина, ИменаКолонокРесурсовИсключений = "") Экспорт
	
	СтруктураКолонок = ИзмеренияРесурсыТаблицы(Таблица, НЕ ПоРесурсам, ИменаКолонокРесурсовИсключений);	
	Таблица.Свернуть(СтруктураКолонок.Измерения, СтруктураКолонок.Ресурсы);
	
КонецПроцедуры

// Сбор данных о колонках таблицы
//
//Параметры:
// Таблица - ТаблицаЗначений
// ВсеИзмерения - Булево - считать все колонки измерениями
// ИменаКолонокРесурсовИсключений - Строка - при автоопределении все колонки, содержащие тип "Число" считаются ресурсными. Если какие-то из
//									них должны быть измерениями, в этот параметр передается список их имен, через запятую.
//
//Возвращаемое значение: 
// Структура
//	*Ключ "Измерения" - Строка - список колонок-измерений, через ","
//	*Ключ "Ресурсы" - Строка - список колонок-ресурсов, через ","
//
Функция ИзмеренияРесурсыТаблицы(Таблица, ВсеИзмерения = Ложь, ИменаКолонокРесурсовИсключений = "") Экспорт
	ТипЧисло = Тип("Число");
	
	ИменаКолонокИзмерений = "";
	ИменаКолонокРесурсов = "";
	Для каждого Колонка Из Таблица.Колонки Цикл		
		ЭтоРесурс = НЕ ВсеИзмерения И Найти(ИменаКолонокРесурсовИсключений, Колонка.Имя) = 0 И Колонка.ТипЗначения.СодержитТип(ТипЧисло);		
		Если ЭтоРесурс Тогда
			ИменаКолонокРесурсов = ИменаКолонокРесурсов + Колонка.Имя + ",";		
		Иначе
			ИменаКолонокИзмерений = ИменаКолонокИзмерений + Колонка.Имя + ",";		
		КонецЕсли; 		
	КонецЦикла; 
	СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(ИменаКолонокИзмерений, 1);
	СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(ИменаКолонокРесурсов, 1);
	
	Результат = Новый Структура("Измерения, Ресурсы", ИменаКолонокИзмерений, ИменаКолонокРесурсов);
	Возврат Результат;	
КонецФункции
 
// Очистка строк таблицы значений, в которых все поля по преданным именам колонок пусты
//
//Параметры:
// Таблица - ТаблицаЗначений
// ИменаПроверяемыхКолонок - Строка - колонки, через запятую
//
Процедура УдалитьПустыеСтрокиТаблицы(Таблица, ИменаПроверяемыхКолонок) Экспорт
	
	МассивПроверяемыхКолонок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИменаПроверяемыхКолонок);
	КоличествоПроверяемыхКолонок = МассивПроверяемыхКолонок.Количество();
	
	МассивСтрокКУдалению = Новый Массив;
	Для каждого СтрокаТаблицы Из Таблица Цикл		
		СчетчикПустыхПолей = 0;
		Для каждого ИмяКолонки Из МассивПроверяемыхКолонок Цикл
			ЗначениеКолонки = СтрокаТаблицы[ИмяКолонки];
			СчетчикПустыхПолей = СчетчикПустыхПолей + Число(НЕ ЗначениеЗаполнено(ЗначениеКолонки));			
		КонецЦикла; 
		
		УдалитьСтроку = СчетчикПустыхПолей = КоличествоПроверяемыхКолонок;
		Если УдалитьСтроку Тогда
			МассивСтрокКУдалению.Добавить(СтрокаТаблицы);	
		КонецЕсли; 		
	КонецЦикла; 
	
	Для каждого СтрокаКУдалению Из МассивСтрокКУдалению Цикл
		Таблица.Удалить(СтрокаКУдалению);		
	КонецЦикла; 	
	
КонецПроцедуры 

// Массив значений колонки коллекци
//
//Параметры:
// Коллекция - ТаблицаЗначений, КоллекцияСтрокДереваЗначений
// ИмяКолонки - Строка
// НеПустые - Булево - в выходном массиве останутся только заполненные значения
// Уникальные - Булево
// Исключения - Массив, Соответствие, Произвольный - элемент, или список элементов которые необходимо исключить из массива
//
//Возвращаемое значение: 
// Массив
//
Функция ЗначенияКолонкиКоллекции(Коллекция, ИмяКолонки, НеПустые = Ложь, Уникальные = Истина, Исключения = Неопределено) Экспорт
	
	ИсключатьЗначения = ЗначениеЗаполнено(Исключения);
	Если ИсключатьЗначения Тогда
		ИсключатьИзМассива = ТипЗнч(Исключения) = Тип("Массив");
		ИсключатьИзСоответствия = ТипЗнч(Исключения) = Тип("Соответствие");		
	КонецЕсли; 	
	
	МассивЗначений = Коллекция.ВыгрузитьКолонку(ИмяКолонки);
	Если Уникальные Тогда			
		УникальныеЗначения = Новый Соответствие;		
		Для Каждого ЗначениеПоля Из МассивЗначений Цикл
			Если ИсключатьЗначения Тогда
				Если ИсключатьИзМассива Тогда
					Если Исключения.Найти(ЗначениеПоля) <> Неопределено Тогда
						Продолжить;						
					КонецЕсли; 
				ИначеЕсли ИсключатьИзСоответствия Тогда 
					Если Исключения.Получить(ЗначениеПоля) <> Неопределено Тогда
						Продолжить;						
					КонецЕсли; 
				ИначеЕсли Исключения = ЗначениеПоля Тогда 
					Продолжить;
				КонецЕсли; 				
			КонецЕсли; 
			
			Если НеПустые И НЕ ЗначениеЗаполнено(ЗначениеПоля) Тогда
				Продолжить;					
			КонецЕсли; 			
			УникальныеЗначения.Вставить(ЗначениеПоля, Истина);
		КонецЦикла;		
		МассивЗначений.Очистить();
		Для каждого КлючИЗначение Из УникальныеЗначения Цикл
			МассивЗначений.Добавить(КлючИЗначение.Ключ);			
		КонецЦикла; 	
		
	ИначеЕсли ЛОЖЬ
		ИЛИ НеПустые
		ИЛИ ИсключатьЗначения Тогда 		
		
		КоличествоЭлементовКоллекции = МассивЗначений.Количество();		
		Для ОбратныйИндекс = 1 По КоличествоЭлементовКоллекции Цикл			
			Индекс = КоличествоЭлементовКоллекции - ОбратныйИндекс;			
			ЗначениеПоля = МассивЗначений[Индекс];
		
			Если ИсключатьЗначения Тогда
				Если ИсключатьИзМассива Тогда
					Если Исключения.Найти(ЗначениеПоля) <> Неопределено Тогда
						Продолжить;						
					КонецЕсли; 
				ИначеЕсли ИсключатьИзСоответствия Тогда 
					Если Исключения.Получить(ЗначениеПоля) <> Неопределено Тогда
						Продолжить;						
					КонецЕсли; 
				ИначеЕсли Исключения = ЗначениеПоля Тогда 
					Продолжить;					
				КонецЕсли; 				
			КонецЕсли; 	
			
			Если НеПустые И ЗначениеЗаполнено(ЗначениеПоля) Тогда				
				Продолжить;				
			КонецЕсли;			
			МассивЗначений.Удалить(Индекс);
		КонецЦикла;	
	
	КонецЕсли;
	
	Возврат МассивЗначений;
	
КонецФункции

// Возвращает массив структур, содержащих информацию из строк таблицы
Функция ТаблицаВМассивСтруктур(Знач ТаблицаЗначений) Экспорт
	Результат = Новый Массив;
	
	ИменаКолонок = "";
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		ИменаКолонок = ИменаКолонок + "," + Колонка.Имя;
	КонецЦикла;
	ИменаКолонок = Сред(ИменаКолонок, 2);
	
	Для Каждого Строка Из ТаблицаЗначений Цикл
		СтруктураСтроки = Новый Структура(ИменаКолонок);
		ЗаполнитьЗначенияСвойств(СтруктураСтроки, Строка);
		Результат.Добавить(СтруктураСтроки);
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Удаление колонки из коллекции, по имени
//
//Параметры:
// Источник - ТаблицаЗначений, ДеревоЗначений
// ИмяКолонки - Строка
//
Процедура УдалитьКолонкуСПроверкой(Источник, ИмяКолонки) Экспорт
	
	КолонкаТаблицы = Источник.Колонки.Найти(ИмяКолонки);
	Если КолонкаТаблицы <> Неопределено Тогда
		Источник.Колонки.Удалить(КолонкаТаблицы);
		
	КонецЕсли; 	
	
КонецПроцедуры

Функция ПолучитьТаблицуИзДинамическогоСписка(ДинамическийСписок) Экспорт
	
	Схема = ДинамическийСписок.ПолучитьИсполняемуюСхемуКомпоновкиДанных();
	Настройки = ДинамическийСписок.ПолучитьИсполняемыеНастройкиКомпоновкиДанных();
	
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных();
	МакетКомпоновки	= КомпоновщикМакета.Выполнить(Схема, Настройки,,,Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	
	ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновки.Инициализировать(МакетКомпоновки);
	
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	Возврат ПроцессорВывода.Вывести(ПроцессорКомпоновки);
	
КонецФункции
	
Процедура УдалитьСтрокиКоллекции(Коллекция, ИмяФлаговойКолонки = "Удалить", ЗначениеФлаговойКолонки = Истина, УдалитьФлаговуюКолонку = Истина) Экспорт
	
	Поиск = Новый Структура(ИмяФлаговойКолонки, ЗначениеФлаговойКолонки);
	Если ТипЗнч(Коллекция) = Тип("ТаблицаЗначений") Тогда
		МассивСтрокКУдалению = Коллекция.НайтиСтроки(Поиск);	
		Для каждого УдаляемаяСтрока Из МассивСтрокКУдалению Цикл
			Коллекция.Удалить(УдаляемаяСтрока);				
		КонецЦикла; 
		
	ИначеЕсли ТипЗнч(Коллекция) = Тип("ДеревоЗначений") Тогда 		
		МассивУзловКУдалению = Коллекция.Строки.НайтиСтроки(Поиск, Истина);		
		Для каждого УзелКоллекции Из МассивУзловКУдалению Цикл			
			РодительУзла = УзелКоллекции.Родитель;
			Если РодительУзла =Неопределено Тогда
				РодительУзла = Коллекция;				
			КонецЕсли; 			
			РодительУзла.Строки.Удалить(УзелКоллекции);
		КонецЦикла; 
		
	КонецЕсли; 
	
	Если УдалитьФлаговуюКолонку Тогда
		Коллекция.Колонки.Удалить(ИмяФлаговойКолонки);		
	КонецЕсли; 	
	
КонецПроцедуры

// Добавляет колонки в коллекцию
//
// Параметры:
//  Коллекция	 - ТаблицаЗначений, КоллекцияСтрокДереваЗначений	 - 
//  ИменаКолонок - Строка	 - Имена колонок через запятую
//
Процедура ДобавитьКолонкиВКоллекцию(Коллекция, ИменаКолонок) Экспорт
	
	Для Каждого Элемент Из Новый Структура(ИменаКолонок) Цикл
		Коллекция.Колонки.Добавить(Элемент.Ключ);
	КонецЦикла; 
	
КонецПроцедуры

Процедура ОставитьВсеВхожденияТипаВМассиве(Массив, Тип, Отбор = Неопределено) Экспорт
	
	Перем СтруктураОбъекта;
	Если Отбор <> Неопределено Тогда
		СтруктураОбъекта = Новый Структура(ОбщегоНазначенияКлиентСервер.КлючиСтруктурыВСтроку(Отбор));
	КонецЕсли; 
	
	КоличествоЭлементовКоллекции = Массив.Количество();
	
	Для ОбратныйИндекс = 1 По КоличествоЭлементовКоллекции Цикл
		
		Индекс = КоличествоЭлементовКоллекции - ОбратныйИндекс;
		
		Если ТипЗнч(Массив[Индекс]) <> Тип Тогда
			
			Массив.Удалить(Индекс);
			
		ИначеЕсли Отбор <> Неопределено Тогда 
			
			ЗаполнитьЗначенияСвойств(СтруктураОбъекта, Массив[Индекс]);
			
			Если Не ОбщегоНазначения.КоллекцииИдентичны(СтруктураОбъекта, Отбор) Тогда
				
				Массив.Удалить(Индекс);
				
			КонецЕсли; 
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти 

#Область ЗамерПроизводительности

Процедура ТочкаОстановаНачало() Экспорт
КонецПроцедуры

Процедура ТочкаОстановаОкончание() Экспорт
КонецПроцедуры

#КонецОбласти

#Область РАБОТА_С_ОБЪЕКТАМИ_МЕТАДАННЫХ

Функция СтруктураСвойствОбъектаМетаданных(ОбъектМетаданных, Рекурсивно = Ложь) Экспорт
	
	Структура = Новый Структура;
	
	Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(ОбъектМетаданных, "Реквизиты") Тогда
		
		Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
			Структура.Вставить(Реквизит.Имя);
		КонецЦикла;
		
	КонецЕсли; 
	
	Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(ОбъектМетаданных, "СтандартныеРеквизиты") Тогда
		
		Для Каждого Реквизит Из ОбъектМетаданных.СтандартныеРеквизиты Цикл
			Структура.Вставить(Реквизит.Имя);
		КонецЦикла;
		
	КонецЕсли; 
	
	Если Рекурсивно И ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(ОбъектМетаданных, "ТабличныеЧасти") Тогда
		
		Для Каждого ТабличнаяЧасть Из ОбъектМетаданных.ТабличныеЧасти Цикл
			Структура.Вставить(ТабличнаяЧасть.Имя, СтруктураСвойствОбъектаМетаданных(ТабличнаяЧасть));
		КонецЦикла; 
		
	КонецЕсли; 
	
	Возврат Структура;
	
КонецФункции

Функция ТаблицаЗначенийПоОбъектуМетаданных(ОбъектМетаданных) Экспорт
	
	Таблица = Новый ТаблицаЗначений;
	Для Каждого Элемент Из ОбъектМетаданных.Реквизиты Цикл
		Таблица.Колонки.Добавить(Элемент.Имя, Элемент.Тип, Элемент.Синоним);
	КонецЦикла; 
	
	Возврат Таблица;
	
КонецФункции

#КонецОбласти 

#Область ПРОЦЕДУРЫ_И_ФУНКЦИИ_РАБОТЫ_СО_СТАТУСОМ_ДОКУМЕНТОВ

// Позволяет получить индекс картинки состояния документа из коллекции СостоянияДокумента
// по свойствам Проведен/ПометкаУдаления/РучнаяКорректировка
//
// Параметры:
// Объект - основной реквизит формы документа, с типом ДанныеФормыСтруктура
//
Функция СостояниеДокумента(Объект) Экспорт
	
	СостояниеДокумента = 0;
	
	Если Объект.Свойство("РучнаяКорректировка") И Объект.РучнаяКорректировка Тогда
		Если Объект.ПометкаУдаления Тогда
			СостояниеДокумента = 10;
		ИначеЕсли НЕ Объект.Проведен Тогда
			СостояниеДокумента = 9;
		Иначе
			СостояниеДокумента = 8;
		КонецЕсли;
	Иначе
		Если Объект.ПометкаУдаления Тогда
			СостояниеДокумента = 2;
		ИначеЕсли Объект.Проведен Тогда
			
			ЕстьОтложенныеДвижения = РегистрыСведений.ДокументыСОтложеннымДвижениемЕПС.ПоДокументуНеобходимоДопроведение(Объект.Ссылка)
				Или РегистрыСведений.ДокументыСОтложеннымДвижением.ПоДокументуНеобходимоДопроведение(Объект.Ссылка);
			
			Если ЕстьОтложенныеДвижения Тогда
				СостояниеДокумента = 13;
			Иначе 	
				СостояниеДокумента = 1;
			КонецЕсли; 
			
		КонецЕсли;
	КонецЕсли;
	
	Возврат СостояниеДокумента;
	
КонецФункции

Процедура УстановитьСостояниеДокумента(Форма) Экспорт
	
	Форма.СостояниеДокумента = СостояниеДокумента(Форма.Объект);
	
КонецПроцедуры
 
#КонецОбласти 

#Область РАБОТА_С_ДОПОЛНИТЕЛЬНЫМИ_РЕКВИЗИТАМИ_И_СВОЙСТВАМИ

// Возвращает значения дополнительных свойств объектов.
//
// Параметры:
//  ОбъектыСоСвойствами  - Массив      - объекты, для которых нужно получить значения дополнительных свойств.
//                       - ЛюбаяСсылка - ссылка на объект, например, СправочникСсылка.Номенклатура,
//                                       ДокументСсылка.ЗаказПокупателя, ...
//  ПолучатьДопРеквизиты - Булево - в результат включать дополнительные реквизиты. По умолчанию Истина.
//  ПолучатьДопСведения  - Булево - в результат включать дополнительные сведения. По умолчанию Истина.
//  Свойства             - Массив - свойства:
//                          * ПланВидовХарактеристикСсылка.ДополнительныеРеквизитыИСведения - значения
//                            которых следует получить.
//                       - Неопределено - по умолчанию, получить значения всех свойств владельца.
//
// Возвращаемое значение:
//  ТаблицаЗначений - колонки:
//    * Свойство - ПланВидовХарактеристикСсылка.ДополнительныеРеквизитыИСведения - свойство владельца.
//    * Значение - Произвольный - значения любого типа из описания типов свойства объекта метаданных:
//                  "Метаданные.ПланВидовХарактеристик.ДополнительныеРеквизитыИСведения.Тип".
//    * ВладелецСвойств - ЛюбаяСсылка - ссылка на объект.
//
Функция ЗначенияСвойств(ОбъектыСоСвойствами, ПолучатьДопРеквизиты = Истина, ПолучатьДопСведения = Истина, Свойства = Неопределено) Экспорт
	
	ПолучатьДопСведения = ПолучатьДопСведения И ПравоДоступа("Чтение", Метаданные.РегистрыСведений.ДополнительныеСведения);
	
	Если ТипЗнч(ОбъектыСоСвойствами) = Тип("Массив") Тогда
		ВладелецСвойств = ОбъектыСоСвойствами[0];
	Иначе
		ВладелецСвойств = ОбъектыСоСвойствами;
	КонецЕсли;
	
	Если Свойства = Неопределено Тогда
		Свойства = УправлениеСвойствами.ПолучитьСписокСвойств(ВладелецСвойств, ПолучатьДопРеквизиты, ПолучатьДопСведения);
	КонецЕсли;
	
	ИмяОбъектаСоСвойствами = ОбщегоНазначения.ИмяТаблицыПоСсылке(ВладелецСвойств);
	
	ТекстЗапросаДопРеквизиты =
		"ВЫБРАТЬ [РАЗРЕШЕННЫЕ]
		|	ТаблицаСвойств.Свойство КАК Свойство,
		|	ТаблицаСвойств.Значение КАК Значение,
		|	ТаблицаСвойств.ТекстоваяСтрока,
		|	ТаблицаСвойств.Ссылка КАК ВладелецСвойств
		|ИЗ
		|	[ИмяОбъектаСоСвойствами].ДополнительныеРеквизиты КАК ТаблицаСвойств
		|		ЛЕВОЕ СОЕДИНЕНИЕ ПланВидовХарактеристик.ДополнительныеРеквизитыИСведения КАК ДополнительныеРеквизитыИСведения
		|		ПО ДополнительныеРеквизитыИСведения.Ссылка = ТаблицаСвойств.Свойство
		|ГДЕ
		|	ТаблицаСвойств.Ссылка В (&ОбъектыСоСвойствами)
		|	И (ДополнительныеРеквизитыИСведения.Ссылка В (&Свойства))";
	
	ТекстЗапросаДопСведения =
		"ВЫБРАТЬ [РАЗРЕШЕННЫЕ]
		|	ТаблицаСвойств.Свойство КАК Свойство,
		|	ТаблицаСвойств.Значение КАК Значение,
		|	"""" КАК ТекстоваяСтрока,
		|	ТаблицаСвойств.Объект КАК ВладелецСвойств
		|ИЗ
		|	РегистрСведений.ДополнительныеСведения КАК ТаблицаСвойств
		|		ЛЕВОЕ СОЕДИНЕНИЕ ПланВидовХарактеристик.ДополнительныеРеквизитыИСведения КАК ДополнительныеРеквизитыИСведения
		|		ПО ДополнительныеРеквизитыИСведения.Ссылка = ТаблицаСвойств.Свойство
		|ГДЕ
		|	ТаблицаСвойств.Объект В (&ОбъектыСоСвойствами)
		|	И (ДополнительныеРеквизитыИСведения.Ссылка В (&Свойства))";
	
	Запрос = Новый Запрос;
	
	Если ПолучатьДопРеквизиты И ПолучатьДопСведения Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапросаДопРеквизиты, "[РАЗРЕШЕННЫЕ]", "РАЗРЕШЕННЫЕ") + "
			|
			| ОБЪЕДИНИТЬ ВСЕ
			|" + СтрЗаменить(ТекстЗапросаДопСведения, "[РАЗРЕШЕННЫЕ]", "");
		
	ИначеЕсли ПолучатьДопРеквизиты Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапросаДопРеквизиты, "[РАЗРЕШЕННЫЕ]", "РАЗРЕШЕННЫЕ");
		
	ИначеЕсли ПолучатьДопСведения Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапросаДопСведения, "[РАЗРЕШЕННЫЕ]", "РАЗРЕШЕННЫЕ");
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяОбъектаСоСвойствами]", ИмяОбъектаСоСвойствами);
	
	Запрос.Параметры.Вставить("ОбъектыСоСвойствами", ОбъектыСоСвойствами);
	Запрос.Параметры.Вставить("Свойства", Свойства);
	Запрос.Текст = ТекстЗапроса;
	
	Результат = Запрос.Выполнить().Выгрузить();
	РезультатСТекстовымиСтроками = Неопределено;
	ИндексСтроки = 0;
	Для каждого ЗначениеСвойства Из Результат Цикл
		ТекстоваяСтрока = ЗначениеСвойства.ТекстоваяСтрока;
		Если Не ПустаяСтрока(ТекстоваяСтрока) Тогда
			Если РезультатСТекстовымиСтроками = Неопределено Тогда
				РезультатСТекстовымиСтроками = Результат.Скопировать(,"Свойство, ВладелецСвойств");
				РезультатСТекстовымиСтроками.Колонки.Добавить("Значение");
				РезультатСТекстовымиСтроками.ЗагрузитьКолонку(Результат.ВыгрузитьКолонку("Значение"), "Значение");
			КонецЕсли;
			РезультатСТекстовымиСтроками[ИндексСтроки].Значение = ТекстоваяСтрока;
		КонецЕсли;
		ИндексСтроки = ИндексСтроки + 1;
	КонецЦикла;
	
	Возврат ?(РезультатСТекстовымиСтроками <> Неопределено, РезультатСТекстовымиСтроками, Результат);
КонецФункции

// Возвращает соответствие, содержащее значения дополнительных реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
// Функция не предназначена для получения значений реквизитов пустых ссылок.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую
//            - Соответствие, ФиксированноеСоответствие - в качестве ключа передается
//              имя реквизита
//            - Массив, ФиксированныйМассив - имена реквизитов
//
// Возвращаемое значение:
//  Соответствие - содержит имена и значения затребованных дополнительных реквизитов.
//              Если строка затребованных реквизитов пуста, то возвращается пустое соответствие.
//
Функция ЗначенияДополнительныхРеквизитовОбъекта(Ссылка, Знач Реквизиты, ИмяНабораСвойств = "") Экспорт
		
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Соответствие;
		КонецЕсли;
		Реквизиты = СтрРазделить(Реквизиты, ",", Ложь);
	КонецЕсли;
	
	ИменаРеквизитов = Новый Массив;
	Если (ТипЗнч(Реквизиты) = Тип("Массив")) ИЛИ (ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив")) Тогда	
		ИменаРеквизитов = Реквизиты; 
	ИначеЕсли (ТипЗнч(Реквизиты) = Тип("Соответствие")) ИЛИ (ТипЗнч(Реквизиты) = Тип("ФиксированноеСоответствие")) Тогда
		Для каждого КлючИЗначение Из Реквизиты Цикл
	    	ИменаРеквизитов.Добавить(КлючИЗначение.Ключ);
		КонецЦикла;	
	КонецЕсли;
	
	Если ИменаРеквизитов.Количество() = 0 Тогда
		Возврат Новый Соответствие;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ИмяНабораСвойств) Тогда
		ИмяНабораСвойствДляПоиска = ИмяНабораСвойств;
	Иначе	
		ИмяНабораСвойствДляПоиска = ОбщегоНазначения.ВидОбъектаПоСсылке(Ссылка) + "_" + Ссылка.Метаданные().Имя;
	КонецЕсли;
	
	НаборСвойств = ОбщегоНазначенияДУ.НайтиЭлементСправочникаПоРеквизиту(ИмяНабораСвойствДляПоиска, "НаборыДополнительныхРеквизитовИСведений", "ИмяПредопределенныхДанных");
	Если Не ЗначениеЗаполнено(НаборСвойств) Тогда
		Возврат Новый Соответствие;
	КонецЕсли;
	
	СвойстваПоИменам = СвойстваПоИменам(ИменаРеквизитов, НаборСвойств);
	
	МассивСвойств = Новый Массив;
	Для каждого КлючИЗначение Из СвойстваПоИменам Цикл				
		Если ЗначениеЗаполнено(КлючИЗначение.Значение) И УправлениеСвойствами.ПроверитьСвойствоУОбъекта(Ссылка, КлючИЗначение.Значение) Тогда
			МассивСвойств.Добавить(КлючИЗначение.Значение);
		КонецЕсли;		
	КонецЦикла;
	
	ЗначенияСвойств = УправлениеСвойствами.ПолучитьЗначенияСвойств(Ссылка, УправлениеСвойствами.ИспользоватьДопРеквизиты(Ссылка), Истина, МассивСвойств);
	
	Результат = Новый Соответствие;	
	Для каждого КлючИЗначение Из СвойстваПоИменам Цикл
		
		НайденнаяСтрока = ЗначенияСвойств.Найти(КлючИЗначение.Значение, "Свойство");
		Если НайденнаяСтрока <> Неопределено Тогда
			ЗначениеСвойства = НайденнаяСтрока.Значение;
		Иначе	
			ЗначениеСвойства = Неопределено;
		КонецЕсли;
		
		Результат.Вставить(КлючИЗначение.Ключ, ЗначениеСвойства);	

	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Возвращает значение дополнительного реквизита, прочитанного из информационной базы по ссылке на объект.
//
// Функция не предназначена для получения значений реквизитов пустых ссылок.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
//
Функция ЗначениеДополнительногоРеквизитаОбъекта(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ЗначенияДополнительныхРеквизитовОбъекта(Ссылка, ИмяРеквизита);
	Возврат Результат[ИмяРеквизита];
	
КонецФункции

// Возвращает соответствие, содержащее имена дополнительных реквизитов и свойства
//
// Параметры:
//  Реквизиты - Массив - имена реквизитов
//            - Строка - имена реквизитов, перечисленные через запятую
//  НаборСвойств - СправочникСсылка.НаборыДополнительныхРеквизитовИСведений - Набор, для которого необходимо получить свойства.
//
// Возвращаемое значение:
//  Соответствие - содержит имена и значения затребованных дополнительных реквизитов.
//              Если строка затребованных реквизитов пуста, то возвращается пустое соответствие.
//
Функция СвойстваПоИменам(Реквизиты, НаборСвойств) Экспорт
	
	ИменаРеквизитов = Новый Массив;
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Соответствие;
		КонецЕсли;
		ИменаРеквизитов = СтрРазделить(Реквизиты, ",", Ложь);
	ИначеЕсли ТипЗнч(ИменаРеквизитов) = Тип("Массив") Тогда
		ИменаРеквизитов = Реквизиты;
	Иначе
		Возврат Новый Соответствие;
	КонецЕсли;
		
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ДополнительныеРеквизитыИСведения.Ссылка КАК Свойство,
		|	ДополнительныеРеквизитыИСведения.Заголовок КАК Имя
		|ИЗ
		|	ПланВидовХарактеристик.ДополнительныеРеквизитыИСведения КАК ДополнительныеРеквизитыИСведения
		|ГДЕ
		|	ДополнительныеРеквизитыИСведения.Заголовок В(&ИменаРеквизитов)
		|	И ДополнительныеРеквизитыИСведения.ПометкаУдаления = ЛОЖЬ
		|	И ДополнительныеРеквизитыИСведения.НаборСвойств = &НаборСвойств";
	
	Запрос.УстановитьПараметр("ИменаРеквизитов", ИменаРеквизитов);
	Запрос.УстановитьПараметр("НаборСвойств", НаборСвойств);
	
	ОбщегоНазначенияДУ.ДобавитьВЛогОтладки(Запрос, "ОбщегоНазначенияДУ.СвойстваПоИменам");
	
	Свойства = Запрос.Выполнить().Выгрузить();
	
	Результат = Новый Соответствие;
	Для каждого ИмяРеквизита Из ИменаРеквизитов Цикл
		
		НайденнаяСтрока = Свойства.Найти(ИмяРеквизита, "Имя");
		Если НайденнаяСтрока <> Неопределено Тогда
			Свойство = НайденнаяСтрока.Свойство;
		Иначе	
			Свойство = Неопределено;
		КонецЕсли;
		
		Результат.Вставить(ИмяРеквизита, Свойство);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции
 
#КонецОбласти

#Область ОБРАБОТЧИКИ_СОБЫТИЙ_ФОРМЫ

Процедура ОбъектПриЧтенииНаСервере(Форма, ТекущийОбъект) Экспорт
	
	УстановитьСостояниеДокумента(Форма);
	
КонецПроцедуры
 
Процедура ОбъектПослеЗаписиНаСервере(Форма, ТекущийОбъект, ПараметрыЗаписи) Экспорт
	
	УстановитьСостояниеДокумента(Форма);
	
КонецПроцедуры
 
#КонецОбласти 
